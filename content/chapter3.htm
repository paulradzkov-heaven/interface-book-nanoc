--- 
title: 3. Значения, режимы, монотонность и мифы
---


<h1>3. Значения, режимы, монотонность и мифы</h1>

		<div class="epigraph"><blockquote><p>Нет прогресса без
		борьбы.</p>
		<cite>Фредерик Дуглас</cite></blockquote>
		</div>

<p>
Чтобы быть более точными при дальнейшем обсуждении
интерфейсов, мы введем здесь некоторые определения
и условные обозначения. Основанные на понятии
локуса внимания, данного в главе 2, они необходимы
нам для того, чтобы понять, что такое режимы и
каково их негативное воздействие на интерфейсы.
Также в этой главе мы познакомимся с положительным
свойством интерфейсов, которое называется
<i>монотонностью</i> и приводит нас к критике
интерфейсов, предусматривающих разные режимы для
начинающих и опытных пользователей.</p>

<h2>3.1. Терминология и условные обозначения</h2>

		<div class="epigraph"><blockquote><p>Мир делится на людей, которые
		думают, что они правы.</p>
		<cite>Дидр
		Мак-Грат</cite></blockquote>
		</div>

<p>
Содержание (или контент)&nbsp;&mdash; это информация,
которая находится в компьютере или другом
устройстве, предназначенном для обработки
информации, и которая является для вас осмысленной
и полезной. Создание или изменение содержания&nbsp;&mdash;
это та задача, которую вы предполагаете выполнить
с помощью упомянутого устройства. Если вы
писатель, содержание&nbsp;&mdash; это те ваши произведения,
которые хранятся в системе. Если вы художник, ваши
рисунки представляют собой содержание системы.
Сама система&nbsp;&mdash; компьютер, а также меню,
пиктограммы и другие его принадлежности&nbsp;&mdash; не
является содержанием, если только
вы<a name="p54"></a> 
не программист и не разработчик интерфейсов.
Теперь мы можем перефразировать первый закон
робототехники Азимова (см. главу&nbsp;1) в терминах
содержания: &laquo;Никакая система не может причинить
вред содержанию или своим бездействием допустить,
чтобы содержанию был причинен вред&raquo;.</p>

<p>
<b>Графическое устройство ввода</b> (ГУВ)&nbsp;&mdash; это
механизм для передачи системе информации об
определенном местоположении или выборе объекта на
экране монитора. В качестве примера типичного ГУВ
можно привести мышь, трэкбол, световое перо,
планшетный карандаш (tablet pen), джойстик или
тачпад. Под <b>кнопкой ГУВ</b> будет
подразумеваться основная кнопка любого ГУВ,
например левая кнопка двухкнопочной мыши. Как
правило, графическое устройство ввода используется
для управления местоположением курсора, который
представлен на экране монитора в виде стрелки или
другого значка, являющегося системной
интерпретацией указываемого вами места. Поскольку
в конкретный момент мы можем направить свое
внимание только на один курсор, система не должна
отображать более одного курсора для каждого
имеющегося графического устройства ввода. В
приложении А приведено обоснование тому, почему у
мыши должна быть только одна кнопка.</p>

<p>
Одно нажатие и отпускание клавиши или
переключателя без каких-либо промежуточных
действий мы будем называть <b>нажатием</b> (tap).
Этот термин относится только к клавишам на
клавиатуре или другим контактным переключателям
без фиксации, которые при отпускании автоматически
возвращаются в исходное положение и электрическое
состояние.</p>

<p>
<b>Щелкнуть</b> (click) означает расположить курсор в
определенном месте, а затем нажать и отпустить
кнопку ГУВ. Таким образом, выражение &laquo;щелкните на
слове <i>аллигатор</i>&raquo; означает, что вам
требуется навести курсор на слово <i>аллигатор</i>
и затем, не меняя позицию курсора, нажать кнопку
ГУВ и отпустить ее. <b>Перетащить</b> (drag) означает
нажать кнопку ГУВ в одном местоположении курсора,
переместить его в другое место и уже затем
отпустить кнопку. Это действие еще иногда
называется <i>щелкнуть и перетащить</i> (click and
drag). <b>Дважды щелкнуть</b> (double click) означает
расположить курсор в определенном месте, а затем
два раза быстро нажать кнопку ГУВ без
промежуточного движения или какого-либо другого
действия. (На практике небольшое движение
допустимо&nbsp;&mdash; обычно ГУВ слегка смещается в момент
нажатия кнопки.) В некоторых интерфейсах
применялись тройные щелчки, а также щелчки с еще
большим количеством нажатий.</p>

<p>
Существуют различные варианты обозначений для
комбинаций клавиш, используемых при управлении
большей частью программного обеспечения. Например,
нажатие клавиши <kbd>&lt;Ctrl&gt;</kbd> и, при ее
удерживании, нажатие и удерживание клавиши
<kbd>&lt;Shift&gt;</kbd> и затем, при нажатом
положении обеих этих клавиш, нажатие клавиши с
буквой <kbd>t</kbd> часто
обозначается<a name="p55"></a> 
в руководствах как
<kbd>&lt;Ctrl&gt;-&lt;Shift&gt;-&lt;t&gt;</kbd> или 
<kbd>&lt;Ctrl&gt;+&lt;Shift&gt;+&lt;t&gt;</kbd>.
Однако эти обозначения операций с клавишами нельзя
отличить от условных обозначений
последовательностей действий 
<kbd>Control</kbd>, <kbd>дефис</kbd>,
<kbd>Shift</kbd>, <kbd>дефис</kbd>, <kbd>t</kbd> или 
<kbd>Control</kbd>, <kbd>плюс</kbd>, <kbd>Shift</kbd>,
<kbd>плюс</kbd>, <kbd>t</kbd> соответственно.</p>

<p>
Такая двусмысленность может приводить к ошибкам.
Например, когда я работал над рукописью этой
книги, мне понадобилось посмотреть, какая
комбинация клавиш применяется для выполнения
необходимой мне команды. В руководстве было
указано (в конце предложения)</p>

<p>
<kbd>Control+.</kbd></p>

<p>
Поэтому я нажал <kbd>&lt;Ctrl&gt;</kbd> и затем,
удерживая эту клавишу, ввел знак &laquo;плюс&raquo;. Из-за
двусмысленного обозначения в руководстве я сделал
ошибку. На самом деле требовалось при нажатой
клавише <kbd>&lt;Ctrl&gt;</kbd> нажать клавишу со
знаком точки.</p>

<p>
Кроме того, эти обозначения не дают возможности
отразить такие действия, как, например,
одновременное нажатие и удерживание клавиш
<kbd>&lt;Ctrl&gt;</kbd> и <kbd>&lt;Shift&gt;</kbd>
с последующим вводом нескольких алфавитных
символов, причем клавиша <kbd>&lt;Shift&gt;</kbd>
отпускается после ввода первых двух символов, а
<kbd>&lt;Ctrl&gt;</kbd> остается нажатой.
Альтернативный вариант, который я только что
использовал,&nbsp;&mdash; выражение операций обычным
языком, что хотя и понятно, но довольно громоздко.</p>

<p>
Чтобы обозначать операции с клавишами точно и
кратко, я использую символ стрелки, указывающей
вниз, сразу после названия клавиши, на которую
требуется нажать и удерживать в нажатом
состоянии,&nbsp;&mdash; например, <kbd>Shift&darr;</kbd>
означает, что необходимо нажать и удерживать
клавишу <kbd>&lt;Shift&gt;</kbd>. Символ стрелки,
указывающей вверх, после названия клавиши
показывает, что эту клавишу следует отпустить,&nbsp;&mdash;
например <kbd>Shift&uarr;</kbd>. Нажатие одной клавиши,
скажем, клавиши <kbd>&lt;t&gt;</kbd>, может быть
точно обозначено с помощью записи <kbd>t&darr;t&uarr;</kbd>. Запись нажатия одной клавиши можно
сократить до <kbd>t&darr;&uarr;</kbd> или просто до
<kbd>t</kbd>, если это не вызывает двусмысленности и
не может привести к путанице.</p>

<p>
Между отдельными действиями, которые следуют друг
за другом, ставится пробел. Нажатие клавиши
пробела обозначается словом</p>

<p>
<kbd>Пробел</kbd></p>

<p>
Это обозначение невозможно перепутать с набором
слова <kbd>пробел</kbd> (space), потому что
последовательность символов этого слова, вводимая
с клавиатуры, будет записываться буквами,
разделенными пробелами, а именно:</p>

<p>
<kbd>п р о б е л</kbd></p>

<p>
Когда есть риск неверного истолкования или
необходимо сделать акцент на каждом отдельном
действии, я применяю полную запись:</p>

<p>
<kbd>п&darr; п&uarr; р&darr; р&uarr; о&darr; о&uarr; б&darr; б&uarr; е&darr; е&uarr; л&darr; л&uarr;</kbd></p>

<p>
<a name="p56"></a>
Любые комбинации клавиш могут быть линейно
представлены в этой системе записи. Например,
нажатие и удерживание клавиши
<kbd>&lt;Shift&gt;</kbd>, затем нажатие клавиши
<kbd>&lt;n&gt;</kbd>, после этого нажатие и
удерживание клавиши <kbd>&lt;Ctrl&gt;</kbd> при
все еще нажатой клавише <kbd>&lt;Shift&gt;</kbd>,
затем нажатие клавиши <kbd>&lt;k&gt;</kbd>,
отпускание клавиши <kbd>&lt;Shift&gt;</kbd> при
все еще нажатой клавише <kbd>&lt;Ctrl&gt;</kbd>,
затем нажатие клавиши <kbd>&lt;w&gt;</kbd>
и после этого отпускание клавиши
<kbd>&lt;Ctrl&gt;</kbd> записывается следующим
образом:</p>

<p>
<kbd>Shift&darr; n Control&darr; k Shift&uarr; w Control&uarr;</kbd></p>

<p>
При условии, что порядок отпускания клавиш не
имеет значения для работы интерфейса, отпускание
любой из нажатых клавиш обозначается стрелкой
вверх для каждой отдельной клавиши. Таким образом,
набор слова <kbd>пробел</kbd> будет записываться так:</p>

<p>
<kbd>п&darr;&uarr; р&darr;&uarr; о&darr;&uarr; б&darr;&uarr; е&darr;&uarr; л&darr;&uarr;</kbd></p>

<p>
Приведем еще один полезный пример. Чтобы
восстановить исходное состояние ОЗУ на компьютере
Macintosh, должна быть выполнена следующая
последовательность команд:</p>

<p>
<kbd>Command&darr; Control&darr; Power&darr; &uarr;&uarr;&uarr; Command&darr; Option&darr; p&darr; r&darr;</kbd></p>

<p>
Все клавиши требуется удерживать до тех пор, пока
не зазвучит сигнал, после чего:</p>

<p>
<kbd>&uarr;&uarr;&uarr;&uarr;</kbd></p>

<p>
(Выражаясь обычным языком: нажмите и удерживайте
клавишу <kbd>&lt;Command&gt;</kbd>&nbsp;&mdash; отсутствие
стрелки вверх означает, что клавишу не следует
отпускать сразу же. Затем нажмите и удерживайте
клавишу <kbd>&lt;Ctrl&gt;</kbd>. Здесь также нет
стрелки вверх, поэтому следует, удерживая обе эти
клавиши одновременно, нажать клавишу
<kbd>&lt;Power&gt;</kbd>. Ни одной стрелки вверх
еще не было, так что сейчас вы удерживаете сразу
три клавиши. Последующие три стрелки вверх
означают, что требуется отпустить все три клавиши
в любом порядке или одновременно. Затем, как
следует из записи, вам необходимо нажать, не
отпуская, клавишу <kbd>&lt;Command&gt;</kbd>,
затем нажать, не отпуская, клавишу
<kbd>&lt;Option&gt;</kbd>, затем нажать, не
отпуская, клавишу <kbd>&lt;p&gt;</kbd>,
после чего нажать и удерживать клавишу <kbd>&lt;r&gt;</kbd>,
так что, в конце концов, вы будете удерживать в
нажатом положении четыре клавиши одновременно. Это
следует делать до звукового сигнала, после чего
все четыре клавиши следует отпустить.)</p>

<p>
Если при наборе последовательности имеет значение
время, то об этом должно быть сказано в
примечании. Например, для набора одной буквы
<kbd>t</kbd> запись будет следующей:</p>

<p>
<kbd>t&darr; t&uarr;</kbd></p>

<p>
Однако при использовании большинства клавиатур,
если между <kbd>t&darr;</kbd> и <kbd>t&uarr;</kbd> происходит
задержка длительностью более 500 мс, на экране
приблизительно каждые 100 мс станут появляться еще
символы <kbd>t</kbd>. Эта функция<a name="p57"></a> 
обычно называется автоповтором. Задержки, в
том числе и те, которые запускают автоповтор,
часто создают проблемы в работе интерфейсов.
Использование задержек в интерфейсах, а также
улучшение механизма автоповтора будут обсуждаться
далее в разделе 6.4.5.</p>

<h2>3.2. Режимы</h2>

		<div class="epigraph"><blockquote><p>Поскольку люди более уступчивы, чем
		компьютеры, бывает легче заставить человека
		приспособиться к ограничениям компьютера, чем
		создать компьютер, приспособленный к потребностям
		человека. И когда это происходит, человек попадает
		в подчинение к компьютеру, а вовсе не
		освобождается им.</p>
		<cite>Карла Дженнингз</cite><blockquote>
		</div>

<p>
Режимы (modes) являются важным источником ошибок,
путаницы, ненужных ограничений и сложности в
интерфейсе. Многие проблемы, создаваемые режимами,
хорошо известны. Тем не менее, практика создания
систем без режимов почему-то не находит широкого
применения в разработке интерфейсов. Прежде чем
приступить к обсуждению методов устранения
режимов, следует рассмотреть их подробно, тем
более что даже среди специалистов по интерфейсам
нет общего мнения относительно того, что
представляет собой режим (Johnson and Engle-beck,
1989).</p>

<p>
Чтобы понимать режимы, нам следует сначала
определить понятие жеста. Жест (gesture)&nbsp;&mdash; это
последовательность действий человека, которая
выполняется автоматически (после старта).
Например, для опытного пользователя набор такого
простого слова, как <i>это</i>, представляет всего
один жест, в то время как для начинающего
пользователя, который еще не вполне овладел
клавиатурой, набор этого слова по буквам будет
состоять из отдельных жестов. Объединение
последовательности действий в жест, связанный с
определенным психологическим процессом,
определяется как <b>формирование модуля</b>
(chunking), т.е. соединение отдельных элементов
когнитивного процесса в единый ментальный модуль,
что позволяет воспринимать множество элементов как
целое (Buxton ,1986, с.&nbsp;475-480; Miller, 1956).</p>

<p>
В большинстве интерфейсов допускается несколько
интерпретаций конкретного жеста. Например, в одном
случае с помощью клавиши <kbd>&lt;Return&gt;</kbd>
можно вставить в текст символ возврата каретки,
тогда как в другом случае нажатие этой клавиши
приводит к исполнению предшествующей строки в
качестве команды.</p>

<p>
Режимы проявляются в том, как реагирует интерфейс
на тот или иной жест. <i>Состояние интерфейса, при
котором интерпретация данного конкретного жеста
остается неизменной, называется режимом.</i> Если
жест получает другую интерпретацию, это значит,
что интерфейс находится в другом режиме. Такое
определение дает ценное первоначальное<a name="p58"></a> 
представление о том, что составляет режим.
Позже мы уточним это определение.</p>

<p>
Фонарик, управляемый с помощью кнопочного
выключателя, может быть либо включен, либо
выключен при условии, что он находится в хорошем
рабочем состоянии. При нажатии кнопки свет
зажигается, если фонарик находился перед этим в
выключенном состоянии, и наоборот, если текущее
состояние &laquo;включено&raquo;, то после нажатия кнопки
фонарик выключается. Два состояния фонарика
соответствуют двум режимам интерфейса. В одном
режиме нажатие кнопки включает свет. В другом
режиме нажатие кнопки выключает свет. Если вы не
знаете текущее состояние фонарика, вы не можете
предсказать, к чему приведет нажатие кнопки. Если
ваш фонарик лежит глубоко в сумке, и вы его не
видите, то не можете узнать, включен свет или нет,
при условии, что это нельзя почувствовать по
температуре. Чтобы убедиться, что фонарик
выключен, вам требуется вынуть его из сумки.
Невозможность определить текущее состояние
фонарика&nbsp;&mdash; это пример классической проблемы,
возникающей в интерфейсе, в котором есть режимы.
По состоянию управляющего механизма невозможно
сказать, какое действие следует выполнить, чтобы
достичь поставленной цели. Оперируя с управляющим
механизмом без одновременной проверки состояния
системы, вы не сможете предсказать, какой
результат будет иметь данная операция.</p>

<p>
К переключателям трудно подобрать надписи.
Например, однажды мне показали интерфейс, в
котором кнопка на экране была подписана
<kbd>Lock</kbd> (Блокировать). Когда пользователи в
первый раз видели эту кнопку, они считали, что
должны нажать на нее для блокировки данных в этом
окне. Когда они делали так, подпись кнопки
изменялась на <kbd>Unlock</kbd> (Разблокировать),
показывая, что при нажатии на эту кнопку данные
разблокировались бы. После этого многие
пользователи удивлялись, что данные оказывались
разблокированными, поскольку кнопка показывала
<kbd>Unlock</kbd>, что они считали индикатором
текущего состояния, как это часто бывает при
использовании переключателей на кнопках и в меню.
Естественно, это приводило к путанице: на самом
деле кнопка показывала <kbd>Lock</kbd>, когда данные
были разблокированы, и <kbd>Unlock</kbd>&nbsp;&mdash; когда
они были заблокированы. Очевидно, что проблему
нельзя решить, просто поменяв надписи таким
образом, чтобы разблокированные данные
обозначались как <kbd>Unlock</kbd>, а заблокированные
как <kbd>Lock</kbd>.</p>

<p>
В данном случае следует, во-первых, использовать
флажок, а не кнопку, а во-вторых, применить более
точные формулировки&nbsp;&mdash; <kbd>Locked</kbd>
(Заблокировано) вместо <kbd>Lock</kbd> (Блокировка),
что будет восприниматься более правильно: если
флажок установлен, значит, данные заблокированы,
если же флажок сброшен&nbsp;&mdash; данные не
заблокированы. Изменения подписей в этом случае не
требуется. Можно использовать более развернутую
формулировку, например: &laquo;Щелкните по этой кнопке,
чтобы разблокировать данные&raquo; или даже: &laquo;Данные в
настоящее время заблокированы.<a name="p59"></a> 
Щелкните по этой кнопке, чтобы
разблокировать их&raquo;. Однако на кнопке или около
флажка, или в меню трудно разместить полное
объяснение, если интерфейс не снабжен функцией
увеличения изображения (см. раздел 6.2).</p>

<p>
Флажки, тем не менее, оставляют неясным, какие еще
есть альтернативы. Например, если флажок отмечен
&laquo;Сохранить в архиве при закрытии&raquo;, то при
закрытии активного окна данные будут сохранены в
архиве. Однако из подписи не понятно, что
произойдет, если этот флажок сброшен. Данные будут
сохранены где-то в другом месте? Или не сохранены
вообще? Или при закрытии окна появится еще
какая-то опция? Самым лучшим решением в этой
ситуации зачастую оказывается использование набора
переключателей (рис.&nbsp;3.1). Такие переключатели не
являются модальными, и пользователь может сразу
определить не только текущее состояние, но и
альтернативы. Независимо от того, применяются ли
флажки или переключатели, важно, чтобы в названиях
употреблялись прилагательные, описывающие
состояние объекта, а не глаголы, описывающие
действие с этим объектом, потому что иначе
пользователю не ясно, действие уже произошло или
только должно произойти.</p>

<div class="image">
<center><img
src="img_3-1.jpg"><br><caption><i><b>Рис.&nbsp;3.1.</b>
Пара. переключателей, обозначенных
прилагательными. Выбранная опция отмечена точкой в
кружке. Изображение слева отражает заблокированное
состояние данных, а справа&nbsp;&mdash; разблокированное
состояние. Путаница маловероятна, поскольку
пользователь видит все возможные
варианты</i></caption></center></div>

<p>
Переключатели стали стандартным средством для
выбора одной из нескольких возможностей, и вряд ли
следует их заменять какими-то другими механизмами.
<i>Используйте переключатели вместо выключателей.
На выключатели стоит полагаться только в том
случае, когда можно видеть значение
контролируемого состояния и оно находится в локусе
внимания пользователя или в кратковременной
памяти.</i></p>

<p>
За исключением случаев, когда текущее состояние
находится в локусе внимания,&nbsp;&mdash; а обычно это не
так,&nbsp;&mdash; выключатели могут приводить к ошибкам.
Такие ошибки обычно имеют кратковременный характер
и легко исправляются. Тем не менее, их нельзя не
учитывать при разработке интерфейсов. Заниматься
разработкой интерфейсов и при этом не обращать
внимания на такие детали&nbsp;&mdash; все равно, что
пытаться исполнить скрипичный концерт, иногда
забывая диезы и бемоли, обозначенные в нотной
записи. Такие ошибки раздражают слушателя тем, что
отвлекают его внимание от музыки. Точно так же
мелкие ошибки в интерфейсе затрудняют ход работы
пользователя.</p>

<p>
<a name="p60"></a>
Другую связанную с режимами трудность, которая
особенно изматывает пользователей компьютеров,
можно проиллюстрировать на примере того, как
работает клавиша <kbd>&lt;Caps Lock&gt;</kbd>, присутствующая на
большинстве типов клавиатур. Часто первым
признаком случайного нажатия этой клавиши
оказывается то, что вы замечаете, что набранное
вами предложение напечатано заглавными буквами, и
только после этого вы замечаете также, что включен
индикатор <kbd>&lt;Caps Lock&gt;</kbd> (если он есть на
клавиатуре). &laquo;Не случайно ругательства
обозначаются в виде цепочки символов, наподобие
#&%!#$&. Именно такая картина возникает, когда
кто-то набирает цифры при ошибочно нажатой клавише
<kbd>&lt;Caps Lock&gt;</kbd>&raquo;,&nbsp;&mdash; утверждает мой коллега доктор
Джеймс Уинтер (личное сообщение, 1998).</p>

<p>
Несколько десятилетий назад Ларри Кларк заметил,
что режимы создают проблемы по той причине, что
привычные действия приводят к неожиданным
результатам (dark, 1979).<a name="r10" href="#f10"><sup>10</sup></a> Наиболее часто
предлагаемое средство против ошибок, порождаемых
режимами, состоит в том, чтобы ясным образом
показывать пользователю текущее состояние системы.
Доктор Дональд Норман охарактеризовал ошибки,
связанные с режимами, как результаты недостаточной
обратной связи, осуществляемой индикатором
состояния системы (Norman, 1983). Однако, на мой
взгляд, истинной причиной является не
недостаточная обратная связь, а то, что этот
индикатор не находится в локусе внимания
пользователя.</p>

<p>
Особенно показательный пример неудачного
применения индикатора, отражающего текущее
состояние системы, можно встретить в интерфейсе
системы автоматизированного проектирования (САПР)
(computer-aided design, CAD) Vellum (Ashlar,
1995), во всех остальных отношениях превосходном.
Всем, кто занимается разработкой графических
пакетов, я настоятельно рекомендую изучить
программу Drafting Assistant, разработанную
Ashlar. Эта программа оснащена чрезвычайно удобным
интерфейсом, намного более эффективным и приятным
в использовании, чем тот, который применяется в
более известном пакете AutoCAD.<a name="r11" href="#f11"><sup>11</sup></a> Одной из функций,
предусмотренных для экономии времени в пакете
Vellum, является указатель, который может
следовать по внутренней или наружной стороне
геометрической фигуры, выделяя<a name="p61"></a> 
(трассируя) описываемую границу. Чтобы перейти
в режим трассировки, необходимо щелкнуть по
соответствующей кнопке палитры инструментов, при
этом стандартный курсор <img src="cursor1.gif"> преобразуется в
курсор особой, &laquo;указательной&raquo; формы
<img src="cursor2.gif">. По завершении выделения легко
забыть переключиться назад, к стандартному
курсору. Выделение с помощью мыши является
настолько частым действием, что для меня оно уже
давно стало автоматичным, и поэтому когда в этой
программе я щелкаю, чтобы выделить какой-то объект
после операции трассировки, то вместо успешного
выделения я с удивлением обнаруживаю, что
обведенный указателем контур исчезает. Я совершаю
эту ошибку уже не первый год, так же как и другие
пользователи, с которыми мне приходилось говорить
об этом. Хотя иногда я и ловлю себя на мысли, что
делаю неправильно, но все же я никогда <i>не
смогу</i> научиться всегда замечать, что нахожусь
в режиме трассировки, так как выделение с помощью
мыши, для меня во всяком случае, является
автоматичным действием. В локусе моего внимания
находится объект выделения, но не форма курсора.
Изменяющийся курсор, используемый в Vellum,&nbsp;&mdash;
это один из множества примеров, подтверждающих,
что средства обратной связи и индикаторы текущего
положения недостаточны, чтобы обеспечить
устранение ошибок, вызываемых режимами, даже в том
случае, когда индикатор расположен в
непосредственной близости от локуса вашего
внимания. Он может попадать в область высокой
зрительной способности, например, когда
индикатором служит курсор, и тем не менее, вы не
сможете заметить сообщение, передаваемое этим
индикатором, поскольку он не находится в локусе
вашего внимания. Необходимой темой для будущих
исследований должно стать определение частоты
ошибок, связанных с режимами, и выяснение условий,
влияющих на частоту их возникновения.</p>

<p>
Опыт не избавляет от ошибок, порождаемых режимами,
поскольку у опытного пользователя уже имеются
устойчивые привычки. Отсутствие опыта также не
защищает от этих ошибок. В примере с курсорами в
программе Vellum начинающий пользователь еще не
сформировал привычку переключения в режим обычного
курсора после использования указателя трассировки.
По мере приобретения опыта в использовании этой
функции начинающий пользователь научится делать
такое переключение не задумываясь, а значит,
теперь возникает проблема привычек. Если текущее
состояние интерфейса не находится в локусе
внимания пользователя и если интерфейс может
работать в разных режимах, то пользователь будет
иногда совершать ошибки, поскольку текущий режим
не находится в локусе его внимания.</p>

<p>
Приведем другой пример. В некоторых популярных
моделях компьютеров для создания нового документа
применяется следующее сочетание клавиш:</p>

<p>
<kbd>Command&darr; n&darr;&uarr; &uarr;</kbd></p>

<p>
<a name="p62"></a>
Здесь <kbd>n</kbd> обозначает <kbd>новый</kbd> (new). Но
если взять пакет электронной почты America Online,
то в нем для получения нового бланка сообщения
требуется использовать другую комбинацию клавиш:</p>

<p>
<kbd>Command&darr; m&darr;&uarr; &uarr;</kbd></p>

<p>
Я предполагаю, что <kbd>m</kbd> здесь обозначает
<kbd>почта</kbd> (mail). Ошибка, которую совершают
пользователи при создании нового сообщения,
заключается в нажатии неверной комбинации клавиш:</p>

<p>
<kbd>Command&darr; n&darr;&uarr; &uarr;</kbd></p>

<p>
Здесь состояние интерфейса, в котором возникает
режим, зависит от активного приложения. Проблема
возникает в тот момент, когда пользователь
применяет по привычке команду <kbd>Command&darr;
n&darr;&uarr; &uarr;</kbd>.  Начинающий сделает ту же
самую ошибку, но, вероятно, по другим причинам. Он
может подумать, что команда <kbd>Command&darr;
n&darr;&uarr; &uarr;</kbd> работает одинаковым образом
во всех приложениях, и поэтому совершит ту же
ошибку по незнанию.</p>

<p>
Норман (1983) указывает три метода предотвращения
модальных (т. е. связанных с режимами) ошибок:</p>

<ol>
<li>
<p>
Не использовать режимы.</p></li>

<li>
<p>
Обеспечить четкое различие между режимами.</p></li>

<li>
<p>
Не использовать одинаковые команды в разных
режимах, чтобы команда, примененная не в том
режиме, не могла привести к неприятностям.</p>
</ol>

<p>
Из приведенных трех методов только первый
позволяет полностью избежать модальных ошибок. Что
касается второго метода, то, как мы могли уже
убедиться, он не всегда работает. Третий метод не
сокращает количество ошибок, но позволяет
уменьшить их негативные последствия.</p>

<p>
В самом крайнем случае можно привлекать внимание
пользователя к индикатору текущего режима, но это
так же нежелательно, как и сама модальная ошибка,
для предотвращения которой индикатор предназначен,
поскольку локус внимания пользователя будет
переключаться с задачи на текущее состояние
системы. Норман определяет модальные ошибки как
ошибки, возникающие в результате того, что
пользователь неверно классифицирует или
анализирует ситуацию (Norman, 1981). Термины
<i>неверно классифицировать</i> и
<i>анализировать</i> в данном случае указывают на
активное, сознательное участие со стороны
пользователя и, таким образом, могут применяться
до тех пор, пока он еще не в полной мере знаком с
той или иной командой, но не тогда, когда
применение этой команды стало для него
автоматичным.</p>

<h3>3.2.1. Определение режимов</h3>

<p>
Если бы определение режима основывалось
исключительно на конструкции интерфейса (как мы
это до сих пор допускали в нашем изложении), тогда
все пользователи делали бы одинаковые ошибки, хотя
и с разной частотой. Однако это не так. Данный
элемент интерфейса может для одного пользователя
быть модальным, а для другого&nbsp;&mdash; нет. Более
полное определение режима должно включать в себя
то, как пользователь рассматривает интерфейс:
<i>интерфейс &laquo;человек-машина&raquo; является модальным
по отношению к данному жесту, если, во-первых,
текущее состояние интерфейса не находится в локусе
внимания пользователя и, во-вторых, если в ответ
на некоторый жест интерфейс может выполнить одно
из нескольких возможных действий в зависимости от
текущего состояния системы</i>.</p>

<p>
Интерфейс может быть модальным по отношению к
одному жесту и не быть таковым по отношению к
другому. Чтобы можно было классифицировать тот или
иной интерфейс как истинно немодальный, он не
должен быть модальным для любого жеста.</p>

<p>
Степень модальности <var>Q</var> того или иного
интерфейса может быть определена через
классификацию каждого жеста, допустимого в
интерфейсе, как модального или немодального.
Затем, с учетом вероятности применения данного
немодального жеста <var>N_l</var> выраженной как
<var>р(N_i)</var> и вычисленной для данного
пользователя или в среднем для группы
пользователей, получаем <var>Q=\sum_i p(N_i)</var>.
Диапазон значений <var>Q</var> варьируется от 0
(полностью модальный) до 1 (полностью
немодальный).</p>

<p>
Обе части определения модального жеста необходимы
для решения о том, является ли, например, жест
нажатия клавиши <kbd>&lt;Backspace&gt;</kbd>
модальным или нет. В большинстве компьютерных
интерфейсов, если вы набираете какой-то текст, с
помощью команды <kbd>Backspace</kbd> вы можете удалить
символ, который был введен в самую последнюю
очередь. Если это был символ <kbd>е</kbd>, то нажатие
клавиши удалит символ <kbd>е</kbd>. Если же это был
символ <kbd>х</kbd>, то нажатие клавиши удалит символ
<kbd>х</kbd>. Другими словами, в одном случае клавиша
<kbd>&lt;Backspace&gt;</kbd> служит для удаления
символов <kbd>е</kbd>, а в другом случае&nbsp;&mdash; для
удаления символов <kbd>х</kbd>. Если рассматривать
только вторую часть определения, использование
клавиши <kbd>&lt;Backspace&gt;</kbd> является
модальным, так как то, какой именно символ она
удаляет, зависит от того, какой символ был введен
последним, т.е. содержание характеризует
состояние системы. Однако в том случае, когда вы
осознаете, что удаляемый вами объект находится в
локусе вашего внимания, в соответствии с первой
частью определения данная операция не является
модальной, и поэтому вы не делаете модальных
ошибок, используя клавишу
<kbd>&lt;Backspace&gt;</kbd> для удаления из
текста каких-либо символов или любых других
объектов, которые можно выделить и 
удалить.<a name="r12" href="#f12"><sup>12</sup></a><a name="p64"></a>
С другой стороны, команда, которая устанавливает
для клавиши <kbd>&lt;Backspace&gt;</kbd>
направление удаления (вперед или назад), делает
интерфейс модальным. Ранее установленное
направление удаления обычно уже не находится в
локусе вашего внимания, когда впоследствии вы
используете клавишу <kbd>&lt;Backspace&gt;</kbd>,
поэтому иногда удаление будет происходить в
неожиданном направлении.</p>

<blockquote>
<p>
<b>Предотвращение авиакатастроф через устранение
режимов</b></p>

<p>
Время от времени из-за простых ошибок в
интерфейсах происходят крушения как дистанционно
управляемых летательных аппаратов (RPV,
remote-piloted vehilces), используемых для военных
нужд, так и гражданских радиоуправляемых моделей
самолетов. Чтобы понять ошибку и определить метод
ее исправления, следует, прежде всего, знать
кое-что о том, как эти устройства работают.</p>

<p>
При дистанционном управлении летательным аппаратом
оператор, находящийся на земле, манипулирует
небольшим джойстиком, встроенным в пульт
управления (рис.&nbsp;3.2). Как правило, для того чтобы
временно поднять нос аппарата, требуется потянуть
джойстик на себя, а для того чтобы опустить нос,
требуется толкнуть джойстик от себя. Для наклона
вправо и влево джойстик, соответственно,
перемещается вправо или влево. Перемещение
джойстика вызывает пропорциональное движение
устройства, называемого сервомотором. Сервомотор
механически соединен с управляющей плоскостью,
например с рулем высоты в хвостовом оперении
самолета, позволяющим управлять его продольным
наклоном.</p>

<div class="image">
<center><img
src="img_3-2.jpg"><br><caption><i><b>Рис.&nbsp;3.2.</b>
Пульт дистанционного управления гражданского
летательного аппарата. Обратите внимание на
множество элементов управления, расположенных по
всей лицевой панели пульта и в его верхней
части</i></caption></center></div>

<p>
Сервомотор не имеет стандартного направления
движения относительно движения джойстика
управления, поэтому принято на пульте
устанавливать переключатель, который позволяет
выбрать, какое направление движения джойстика
будет соответствовать тому или иному направлению
движения сервомотора. Это явно модальное действие
вступает в противоречие с привычными реакциями<a name="p65"></a> 
пользователя, как это обычно и происходит при
наличии режимов. Следует сказать, что для
управления несколькими разными летательными
аппаратами зачастую используется один пульт. В
каждом аппарате может быть установлено свое
направление движения сервомоторов, от которого
зависит поведение самолета в воздухе. При
переключении управления между аппаратами оператор
должен проверять положение переключателей,
регулирующих направление движения сервомоторов,
чтобы на перемещение джойстика летательный аппарат
отвечал соответствующими действиями.</p>

<p>
Почти невозможно научить пилота управлять
прибором, когда направление движения сервомоторов
заранее не известно. Например, представьте себе,
что пилот, который готовится выполнить взлет
дистанционно управляемого летательного аппарата,
не знает о том, что переключатель направления
наклона установлен в неверную позицию. Взлет
является очень сложным маневром, требующим
большого внимания. Обычно при взлете самолет
спонтанно слегка заваливается влево или вправо в
момент отрыва от земли, и опытный пилот
автоматически подает небольшой сигнал на
компенсацию этого заваливания. У хорошего пилота
эта реакция настолько быстрая, что, наблюдая со
стороны, можно вообще ничего не заметить. Если
переключатель направления работы сервомоторов
установлен в обратное положение, то заваливание,
естественно, станет еще больше. В этом случае
хорошо тренированный пилот сделает еще большее
компенсирующее отклонение джойстика, тем самым
только усугубляя заваливание. В конце концов,
полет обычно заканчивается разрушением самолета,
как только его крыло касается земли или когда
самолет полностью переворачивается на спину. (Все
эти события могут произойти за доли секунды.) Я
еще не видел ни одного пилота, который смог бы
быстро догадаться о возникшей проблеме и вовремя
изменить свои реакции на обратные, чтобы безопасно
закончить взлет. Такого рода крушения происходили
при мне два раза, несмотря на обязательную
проверку правильности положения переключателя,
регулирующего движение управляющих плоскостей.
Проверка положения переключателя, когда она
выполняется десятки раз, тоже становится привычкой
вплоть до того, что вы можете не заметить,
действительно ли управляющие плоскости движутся в
правильном направлении. (Если они не будут
двигаться вообще, то, естественно, это сразу
привлечет ваше внимание к наличию проблемы.) Тем
не менее, во время таких проверок я сам довольно
часто обнаруживал, что аппарат, который я
собирался поднять в воздух, имел обратное
направление движения сервомоторов. Однако,
испытывая недостаток времени или отвлекаясь на
другие дела, я, как и сотни других пилотов, не
замечал эту неправильность.</p>

<p>
Интересно отметить, что такая ошибка, как правило,
не происходит при первом полете на новом аппарате,
когда вы особенно внимательны к возможным
проблемам. Только после того, как полеты на
каком-то<a name="p66"></a> 
аппарате становятся &laquo;второй натурой&raquo;
или просто привычным делом, она обычно и
случается.</p>

<p>
Этот пример демонстрирует случай, когда режим
невозможно устранить. Режимы изначально присущи
сервомоторам и джойстикам управления. Тем не
менее, из данной ситуации есть выход. В качестве
решения можно предложить следующее: поместить
переключатель направления работы сервомоторов
внутрь самого летательного аппарата, возможно,
сделать его частью самих сервомоторов, и убрать
этот переключатель с пульта управления. Обычно
внутренняя часть корпуса самолета недоступна,
поэтому переключатели могут устанавливаться в
нужное положение при сборке аппарата. Правильность
настройки будет проверяться сборщиками самолета,
затем инспекторами и затем еще раз (как обычно)
пилотом перед первым полетом. Хотя этот метод не
устраняет полностью возможности крушения, но если
первый полет выполнен успешно, то в дальнейшем
проблема переключения сервомоторов уже не должна
возникать на этом аппарате независимо от того,
используется ли данный пульт для управления и
другими летательными аппаратами. С точки зрения
оператора, режим устранен.</p>

<p>
Почти все пульты дистанционного управления
моделями летательных аппаратов снабжены
переключателями направления работы сервомоторов.
Аварии из-за того, что пульт управления находится
в неверном режиме, случаются нередко. Еще большие
проблемы создает возможность устанавливать на
пультах управления и другие режимы с помощью
переключателей с длинными ручками, которые можно
переставить в неверное положение случайно. В
пульте управления, разработанном мною, все эти
тумблеры сделаны таким образом, что перед тем как
переставить их в другое положение, их ручки
требуется сначала вытянуть из пульта (рис.&nbsp;3.3).
Поэтому у меня ни разу не было аварий
из-за того, что какой-то тумблер был случайно
сдвинут в неверное положение. Таким образом,
иногда проблемы с режимами могут быть решены
механическим путем.</p>

<div class="image">
<center><img
src="img_3-3.jpg"><br><caption><i><b>Рис.&nbsp;3.3.</b>
Такие тумблеры нельзя переключить в другое
положение случайно. Перед тем как изменить
положение тумблера, его ручку сначала требуется
немного вытянуть из пульта</i></caption></center>
</div>
</blockquote>

<p>
Режимы также ограничивают диапазон действий
пользователя. Если жест <var>g</var> вызывает действие
<var>a</var> в режиме <var>A</var>, а в режиме <var>B</var> он
вызывает действие<a name="p67"></a> 
<var>b</var>, то для того чтобы выполнить
действие <var>a</var>, необходимо сначала выйти из
режима <var>B</var> (если вы в нем находились) и
переустановить интерфейс в режим <var>A</var>. И
только после этого вы сможете использовать жест
<var>g</var> для выполнения действия <var>a</var>.
Разделение интерфейса на ограниченные области
является неизбежным следствием наличия режимов.
Набор состояний, в которых жест <var>g</var> имеет
конкретную интерпретацию, можно назвать
<b>диапазоном</b> (range) жеста <var>g</var>.
Программное обеспечение, которое продается в виде
прикладных программ, например электронные таблицы,
обычно включает один или несколько пересекающихся
диапазонов. Некоторые диапазоны относительно
велики. Например, следующая последовательность
выполняет действие вырезания почти во всех
приложениях как на платформе Macintosh, так и в
Windows:</p>

<p>
<kbd>Command&darr; x&uarr;</kbd></p>

<p>
Бывают и небольшие диапазоны. Например,
нижеприведенная последовательность позволяет в
некоторых компьютерных играх открывать сундук с
сокровищами, если только он находится в пределах
видимости:</p>

<p>
<kbd>Command&darr; h&uarr;</kbd></p>

<p>
Группирование команд по разным диапазонам, или,
как мы это еще называем, по <i>приложениям</i>,
позволяет понять и научиться использовать сложные
интерфейсы. Тем не менее, существует возможность
организовывать интерфейсы, которые могли бы
создавать меньше ограничений, чем режимы.
<i>Полностью человекоориентированный интерфейс
должен состоять только из одного диапазона</i>.</p>

<p>
В случаях когда интерфейс управляется с помощью
другого компьютера, можно было бы подумать, что
проблема наличия режимов снимается, поскольку
машина может легко запомнить необходимое состояние
интерфейса, просто-напросто внутренне
синхронизируя его с собственным состоянием. Тем не
менее, если интерфейс является модальным, и
программа, управляющая этим интерфейсом,
изначально не получает сведений о текущем
состоянии интерфейса,&nbsp;&mdash; а это может произойти,
если программа подключается после того, как
система была запущена,&nbsp;&mdash; то для управления в
каком-то из режимов системы программа должна быть
оснащена средствами тестирования ее текущего
состояния. В этом отношении особые трудности
создают такие интерфейсные переключатели, для
возвращения которых в исходную позицию требуется
сделать подряд несколько переключений, изменив
состояние системы (затем цикл повторяется
сначала).</p>

<p>
Случай, когда интерфейс управляется внешней
программой, относится к вопросу разработки
человеко-машинных интерфейсов, поскольку набор
сохраняемых команд (называемый макросом), который
может быть выполнен одним жестом, является
рудиментарной формой компьютерной программы.
Макрос не может установить такой переключатель в
какое-либо из его допустимых состояний, если сам
макрос сначала не задаст системе вопрос о ее
текущем состоянии. Об этой
проблеме<a name="p68"></a> 
мы уже говорили на примере фонарика в
сумке. Одно из возможных решений состоит в том,
чтобы обеспечить установку переключателя, имеющего
несколько положений, в некое начальное состояние
сразу после каждого случая его использования. В
результате этого подсчет числа переключений
позволит всегда определить текущее состояние
переключателя. Если предполагается, что
переключатель будет использоваться человеком, то
целесообразно предусматривать не более 5 состояний
переключателя. Другим решением может быть
применение набора переключателей (radio buttons).</p>

<p>
Тем не менее, на этом список проблем, к которым
могут приводить режимы, не исчерпывается. Ко всему
прочему, режимы могут еще лишать пользователя
возможности взаимодействия с системой. Это
особенно заметно в том случае, когда вы вынуждены
прервать свою работу, чтобы ответить на возникшее
окно сообщения. Некоторые разработчики считают,
что принуждение пользователя остановиться или
работать в жестких рамках установленной
последовательности действий оказывается полезным,
так как позволяет системе самой &laquo;направлять&raquo;
действия пользователя. При некоторых
обстоятельствах важно, чтобы пользователь принял
то или иное конкретное решение к какому-то моменту
времени или перед выполнением следующего шага из
последовательности. Если же пользователь не имеет
возможности принять свое решение, то и
необходимости диалога с ним нет. В первом случае
достаточно только поместить на экране часы с
обратным отсчетом, но не следует ограничивать
пользователя в том, чтобы в это время он мог
совершать в системе и другие действия. Во втором
случае пусть на экране появляется сообщение, в
котором говорилось бы, что перед выполнением
очередного шага необходимо принять следующее
решение, но система не должна препятствовать
пользователю в выполнении других операций, не
относящихся к текущей программной
последовательности. Необходимо учитывать,
например, что для принятия решения пользователю
требуется просмотреть какой-то файл или выполнить
какие-то вычисления. Другими словами, запросы и
подсказки должны даваться не модально, а так,
чтобы пользователь мог в максимальной степени
сохранять контроль над системой.</p>

<h3>3.2.2. Режимы, пользовательские настройки и
временные режимы</h3>

<p>
Возможности установки пользовательских настроек
являются одним из примеров режимов и представляют
собой большой источник расстройств для
пользователя. Как ни странно, но такие возможности
обычно подаются как некие преимущества для
пользователя. Существующие сегодня интерфейсы
зачастую оказываются настолько трудными в
применении, что сам пользователь может чувствовать
желание как-то перестроить их. Однако Microsoft
(1995, с.&nbsp;4) особенно рекомендует снабжать
интерфейсы такими функциями. &laquo;Поскольку
пользователи обладают довольно разными навыками и
предпочтениями, они
должны<a name="p69"></a> 
иметь возможность изменять параметры
интерфейса (например, цвет, шрифт и др.) на свое
усмотрение.&raquo; С другой стороны, одна из
пользователей Microsoft Word сравнивала установку
личных настроек с установкой часовой бомбы. Речь
шла о том, что ей необходимо было сделать список в
формате, отличающемся от того, который она обычно
использовала. Для этого она прочитала справку о
том, как делать такие изменения, и затем выбрала
соответствующие настройки. В следующий раз, когда
ей понадобилось сделать список, она
воспользовалась знакомой ей командой <kbd>List</kbd> (Список)
и, естественно, получила тот формат, на который
она переустановила текстовый процессор, а не тот,
который использовала обычно. Ей понадобилось
больше часа, чтобы разобраться в том, что
произошло, и исправить последствия. (В первый
момент она подумала, что возникли неисправности в
программе или что она неправильно применила
команду, поэтому она повторила ее много раз,
прежде чем вспомнить, что до этого изменила
настройки.)</p>

<p>
Боб Фауэлз (Bob Fowels) из компьютерного центра
Пенсильванского государственного университета
отмечает:</p>

<blockquote>
<p>
Пользователи, которые не осознают всей сложности
программы Word, могут столкнуться с трудностями,
если во время быстрой работы с клавиатурой
случайно нажмут клавишу
<kbd>&lt;Command&gt;</kbd>,
<kbd>&lt;Option&gt;</kbd> или
<kbd>&lt;Ctrl&gt;</kbd> в сочетании с какой-то
другой клавишей. Вчера, например, моя жена
столкнулась с проблемой, с которой мне пришлось
повозиться не одну минуту. Всякий раз, когда она
нажимала клавишу <kbd>&lt;Return&gt;</kbd>, на
экране возникал маркированный список. Взглянув на
выпадающее меню Правка, я увидел надпись:
&laquo;Отменить автоформат&raquo;. После нескольких минут
поиска и чтения Справки я-таки нашел место
управления функцией автоформатирования и отключил
ее. То есть каким-то образом она умудрилась
использовать сочетание клавиш, которое включило
эту функцию (личное сообщение, 1998).</p>
</blockquote>

<p>
Пользователь пострадал сразу и от пользовательской
настройки, и от режима, и от сочетания клавиш, и
от излишней сложности интерфейса.</p>

<p>
Пользовательские настройки&nbsp;&mdash; это такие изменения
в программном обеспечении, которые не отражаются в
документации. Например, во время использования
Word я попытался отключить функцию, которая была
мне неизвестна. В Справке я узнал, что мне
следовало всего лишь щелкнуть по соответствующей
кнопке на стандартной панели инструментов. Однако
человек, который пользовался программой до меня,
изменил эту панель инструментов с помощью окна
пользовательских установок, и поэтому необходимой
кнопки на ней не было, и мне потребовалось много
времени, чтобы разобраться, как наладить работу
программы нужным мне образом. Этот инцидент указал
на еще более важную проблему применения
пользовательских настроек, а именно: как можно
протестировать качество интерфейса или написать
документацию для системы, если ее конфигурация
разработчикам не известна заранее? В описанном
мною случае изменение режима, произведенное
предыдущим пользователем, сделало документацию
неверной.</p>

<p>
<a name="p70"></a>
В результате возможность настройки параметров
интерфейса зачастую приводит к изменениям, которые
не являются оптимальными, поскольку пользователь
не всегда может обладать компетентностью
специалиста по разработке интерфейсов. Чаще всего
пользователь будет выбирать тот метод, который
наиболее близок к уже известному ему методу, или
настройку, которая требуется ему только на время.
Некоторые разработчики утверждают, что для
достаточно опытных пользователей следует
предусматривать как можно больше настроек, которые
они могут использовать для изменения системы под
свои нужды. Однако нельзя сказать, что опытные
пользователи вместе с тем являются и хорошими
разработчиками интерфейсов, и, имея привычки в
использовании данного программного продукта, они
особенно заинтересованы в стабильной работе
системы так, чтобы их привычки не потеряли основу
после внесения в систему каких-либо изменений,
пусть даже если они вносятся самими
пользователями.</p>

<p>
Снабжая программу настройками, мы обременяем
пользователя задачей, которая не относится к его
рабочим функциям. Пользователю, скажем,
электронных таблиц приходится изучать не только
эти электронные таблицы, но и опции по их
настройке. <i>Время, которое тратится на изучение
и выполнение пользовательских настроек, большей
частью является потерянным с точки зрения текущей
задачи.</i> Менеджеры часто жалуются на то, что
работники тратят время на &laquo;игры с настройками&raquo;.
Большинство пользователей просто хотят выполнить
свою работу, и их не волнует, какой шрифт по
умолчанию принят в электронных таблицах для цифр:
розовый Palatino, зеленый Garamond или полужирный
разреженный наклонный Bodoni синего цвета.</p>

<p>
Установка персональных настроек в совместно
используемой среде чревато серьезными сбоями, так
как это означает, что в интерфейс могут быть
незаметно внесены изменения. В результате вчера
правильным действием было нажатие на красную
кнопку, а сегодня&nbsp;&mdash; на синюю, так как кому-то
показалось, что синий цвет красивее. Ваши навыки и
привычки становятся ненужными. К тому же,
пользователю системы с личными настройками намного
труднее помочь по телефону или по электронной
почте.</p>

<p>
Персональные настройки кажутся удобными,
демократичными, допускающими расширения, полными
свободы и радости для пользователя, но, тем не
менее, я не знаком ни с одним исследованием, в
котором говорилось бы о повышении продуктивности,
а также <i>объективном</i> улучшении юзабилити и
облегчении в изучении системы. Добавление функций
пользовательских настроек, безусловно, усложняет
систему и делает ее более трудной для изучения.
Могу предположить, что если вы проведете опрос
пользователей, то большинство из них будет в
восторге от большого количества параметров,
настраиваемых самим пользователем. Однако здесь
следует сказать, что когда только появились первые
графические пользовательские интерфейсы,
большинство пользователей утверждало, что никогда
не захотят ими пользоваться.<a name="p71"></a> 
Также важно отметить, что пользователи
настраивают интерфейсы в соответствии со своими
субъективными представлениями. Наблюдения,
сделанные во многих экспериментах, показывают, что
<i>интерфейс, который оптимизирует продуктивность,
не обязательно является интерфейсом, который
оптимизирует субъективные оценки</i> (например,
см. Tullis, 1984, с.&nbsp;137).</p>

<p>
Основная мысль этого утверждения заключается в
том, что если мы являемся опытными разработчиками
интерфейсов и можем в максимальной степени
оптимизировать данный интерфейс, то
пользовательские настройки могут только ухудшить
работу этого интерфейса. Поэтому следует с
осторожностью предоставлять пользователю
возможности по установке личных настроек. Если
пользователь может действительно улучшить работу
интерфейса, внеся в него всего лишь несколько
полезных изменений,&nbsp;&mdash; это значит, что, вероятно,
мы плохо сделали свою работу.</p>

<p>
С другой стороны, если интерфейс какой-то
программы&nbsp;&mdash; как было однажды сказано&nbsp;&mdash; &laquo;такой
же унылый, как и интерфейс в Microsoft Word
97/98&raquo;, то ситуация становится обратной. Почти
любое изменение, произведенное пользователем,
становится почти без преувеличения улучшением. Тем
не менее, интерфейс Word&nbsp;&mdash; это не тот пример, на
который нам следует равняться.</p>

<p>
Режимы, которые исчезают после однократного
применения, создают меньше ошибок, чем те, которые
работают постоянно, просто потому, что они имеют
меньше времени на то, чтобы эти ошибки вызвать. В
уже описанном примере о курсорах в пакете Vellum,
если бы курсор автоматически возвращался в
нормальную форму и к его нормальной функции после
выполнения функции трассирования, это приводило бы
к меньшим ошибкам. Если пользователь применяет
временный режим сразу после его включения, факт
включения этого режима еще не вышел из
кратковременной памяти пользователя, поэтому,
скорее всего, он не сделает какой-нибудь модальной
ошибки. Установку режима можно даже сделать частью
жеста, который выполняет данную команду, и в этом
случае ситуация станет полностью немодальной для
вас. Однако если вы установите режим для некоторой
команды и до ее выполнения отвлечетесь или по
какой-то причине задержитесь, то, вероятнее всего,
вы совершите модальную ошибку.</p>

<p>
С целью избежать режимы, компьютер Canon Cat был
спроектирован без кнопки включения питания.<a name="r13" href="#f13"><sup>13</sup></a> Если
продукт реагирует на жесты в зависимости от того,
включен он или нет, то, следовательно, кнопка
включения<a name="p72"></a> 
питания вводит режим (модальность). Для
экономии энергии Canon Cat автоматически переходит
в режим пониженного энергопотребления, если в
течение 5 минут компьютер не используется. Во
избежание превращения этого состояния в режим,
было предусмотрено, чтобы любое действие
пользователя или любое входящее сообщение без
заметной задержки возвращало компьютер в обычное
состояние. Кроме этого, действие пользователя не
только &laquo;оживляло&raquo; компьютер, но и выполнялось
так же, как если бы машина не находилась в режиме
ожидания.</p>

<p>
Во многих системах при нажатия любой клавиши
компьютер выходит из режима ожидания, но эти
нажатия, а также все последующие, сделанные до
того, как система полностью &laquo;проснется&raquo;, не
производят действия, для которого они были
предназначены. Возможность не терять никакие
нажатия клавиш было довольно элегантным решением.
Например, если у вас случилось вдохновение или вам
потребовалось написать записку во время
телефонного разговора, вы могли просто начать
печатать, не заботясь о том, в каком состоянии
находится Саnon Cat, или даже не глядя на монитор.
Отсутствие режимов (немодальность) характерно тем,
что когда у вас появляются привычки в пользовании
интерфейсом, вам не нужно задумываться или
планировать выполнение того или иного действия,
поэтому внимание целиком сосредоточено только на
содержании вашей работы. (Если же случилось так,
что записку вы стали набирать прямо в середине
какого-нибудь другого текста, вы сможете просто
выделить ее и переместить в другое место после
того, как увековечите свое вдохновение или
закончите телефонный разговор.)</p>

<p>
Иногда разработчики говорят, что режимы нужны
потому, что число необходимых программных функций
превышает число жестов, которые пользователь может
выполнить с помощью клавиатуры и графического
устройства ввода, поэтому жесты должны
использоваться многократно. Однако число команд,
исполняемых с помощью монитора (например, меню), и
команд, вводимых с клавиатуры в командную строку и
содержащих множество символов, может быть
неограниченным и потому позволяет избежать
упомянутой трудности. (О том, как сделать видимыми
различные команды, доступные из командной строки,
вместо того чтобы запоминать их, мы поговорим
позже.)</p>

<p>
Можно сделать следующий вывод относительно
режимов: <i>если вы разрабатываете модальный
интерфейс, учитывайте, что пользователи будут
всегда совершать модальные ошибки за исключением
тех случаев, когда значение состояния,
контролируемого данным режимом, находится в локусе
внимания пользователя (и он может его видеть) либо
в его кратковременной памяти. Задача разработчиков
состоит в том, чтобы, показать, что данный режим
используется правильно или что преимущества
данного режима перевешивают его неизбежные
недостатки</i>. Тем не менее, безопаснее всегда
избегать применения режимов в разработке
интерфейсов.</p>

<blockquote>
<p>
<b>Кнопки, которые меняются за одну ночь</b></p>

<p>
На некоторых самолетах используются кнопки, на
которых имеется небольшой точечный дисплей,
отражающий текущее назначение кнопки. Изменение
назначения кнопки контролируется бортовым
компьютером в течение всего полета. Рекламный
вариант одной из моделей таких кнопок показал их
преимущества с точки зрения так называемого
человеческого фактора. Во-первых, при
использовании этих кнопок требуется их меньшее
количество, что важно, так как площадь кабины
самолета ограничена. Во-вторых, эти кнопки
позволяют вносить изменения в бортовое электронное
оборудование и другие системы самолета без
необходимости переделывать электропроводку внутри
кабины.</p>

<p>
С точки зрения когнетики, чем понятнее надписи,
тем лучше их видно. На первый взгляд кажется, что
человек, который отбирает необходимые надписи,
должен провести тестирование словесных
формулировок, которые в них используются, и
убедиться в том, что отобранные символы являются
эффективными и понятными.</p>

<p>
Однако при более тщательном размышлении
выясняется, что эти кнопки могут представлять
некоторые потенциальные проблемы. Следует
учитывать, что надпись на кнопке закрывается
пальцем как раз в момент нажатия на нее, тем самым
не давая в самую последнюю секунду проверить, что
это кнопка&nbsp;&mdash; правильная. Но это еще не самая
большая проблема, поскольку перед тем как нажать
кнопку, вы обычно смотрите на надпись на ней,&nbsp;&mdash;
если вообще куда-нибудь смотрите. (Конечно, я не
смотрю на обозначения на кнопках, когда сейчас
набираю текст на клавиатуре.)</p>

<p>
Есть еще и другая, более глубокая проблема,
касающаяся &laquo;исчезновения&raquo; кнопок. Например, вы
хотите включить ручное управление
кондиционированием в салоне. Вы вспоминаете, что
есть кнопка с надписью MANUAL AIR (Ручное
управление кондиционером), но нигде не можете ее
найти. Дело в том, что на ней стоит другое
обозначение&nbsp;&mdash; СОММ BACKUP (Резервная связь).
Поэтому вам необходимо подумать, как вернуть то
обозначение, которое было раньше на этой кнопке.
Возможно, где-то установлен еще один тумблер или
кнопка, с помощью которых обозначения на кнопках
можно изменить. Или, вероятно, обозначения
являются контекстными и поэтому не позволят вам
включить кондиционирование прямо сейчас. Как бы то
ни было, когда кнопки могут иметь изменяемые
назначения, то нужная вам кнопка может исчезнуть,
если система окажется в другом режиме.</p>

<p>
Но самая серьезная проблема связана с привычками.
Представьте, что опытный пилот протягивает руку,
чтобы нажать какую-то кнопку. Радиосвязь не
работает из-за каких-то неполадок. Необходимо
включить резервную связь. Пилот сразу нажимает
кнопку СОММ BACKUP.<a name="p74"></a> 
Щелк! Но ничего не выходит. Дело в
том, что незадолго до этого второй пилот по
просьбе пассажира регулировал температуру в
салоне, и поэтому кнопки находятся в режиме
регулирования климата. То есть нажатием этой
кнопки командир корабля просто включил ручное
управление системы кондиционирования корабля.</p>

<p>
Кнопки с изменяемыми названиями могут быть
полезны, например, когда консоль используется
одновременно несколькими людьми таким образом, что
кнопки сохраняют свои обозначения только для
каждого отдельного пользователя. Но такая ситуация
встречается редко. Программируемые клавиши,
которые могут иметь разные назначения, влияющие на
экранные кнопки, или кнопки настройки дисплея
имеют те же слабые места, что и кнопки с
изменяемыми значениями. Сходная проблема возникает
при использовании функциональных клавиш, которые
на многих компьютерах обозначены символами от F1
до F12. Если бы их функции оставались неизменными,
то такое название, конечно, являлось бы неудобным.
Если же их функции изменяются, то вы не можете
пользоваться этими клавишами автоматично. В любом
случае их можно назвать неудачным решением.</p>
</blockquote>

<blockquote>
<p>
<b>Чем меньше кнопок, тем лучше?</b></p>

<p>
Переносной осциллограф Флюка<a name="r14" href="#f14"><sup>14</sup></a>, который я недавно
тестировал (рис.&nbsp;3.4), кажется невероятно мощным и
надежным устройством. 35 кнопок, которыми он
оснащен, контролируют несчетное количество режимов
и функций. Мне было трудно научиться пользоваться
этим прибором, и оказалось, что с ним невозможно
работать быстро, если пытаться работать со многими
его функциями.</p>

<div class="image">
<center><img
src="img_3-4.jpg"><br><caption><i><b>Рис.&nbsp;3.4.</b>
Измерительный прибор Флюка. Мощный прибор с
простым дизайном, с бесчисленным множеством
функции и малым количеством кнопок, которым трудно
научиться пользоваться и в котором иногда бывает
трудно добраться до не обходимой вам функции. С
другой стороны, при бор снабжен щупами разных
цветов, что исключает традиционный источник
путаницы относительно того, какой щуп для чего
предназначен</i></caption></center></div>

<p>
<a name="p75"></a>
Осциллограф Tektronix (рис.&nbsp;3.5) с мириадами
настроек, которые на первый взгляд выглядят
отпугивающими, все же легче и изучить, и
использовать. Количество переключателей и ручек
почти такое же, как и у цифрового прибора, но
многие из управляющих ручек имеют множество
настроек, которые доступны сразу. Кроме того,
настройки на передней панели обозначены таким
образом, что сразу заметны, а не спрятаны в меню,
которые требуется еще вызвать, чтобы увидеть.
Прибор Флюка предлагает гораздо большую
функциональность, но за счет усложнения некоторых
задач, которые раньше были довольно простыми.
Поворачивающиеся ручки, конечно, являются намного
более простыми в использовании, чем любая из
кнопок в приборе Флюка. Следует еще добавить, что
Флюк перестарался в создании слишком ветвящейся
структуры подменю.</p>

<div class="image">
<center><img
src="img_3-5.jpg"><br><caption><i><b>Рис.&nbsp;3.5.</b>
Осциллограф Tektronix снабжен мириадами настроек,
и хотя в первый момент и кажется очень сложным, с
ним, тем не менее, можно легко и быстро работать.
Все ручки, которые могут изменить настройку
прибора, обозначены красным
цветом</i></caption></center></div>

<p>
По относительной легкости использования эти
осциллографы очень напоминают мне два
радиоприемника. В моей авторадиоле (рис.&nbsp;3.6)
имеются предварительные настройки для 18
радиостанций, сгруппированные в 3 группы по шесть
станций каждая. С помощью специальной кнопки можно
переходить от одной группы к другой, а ряд из 6
кнопок соответствует станциям в каждой группе. На
жидкокристаллическом экране отображается номер
группы (от 1 до 3). Таким образом, семи кнопок
оказывается достаточно для выбора 24 станций.</p>

<div class="image">
<center><img
src="img_3-6.jpg"><br><caption><i><b>Рис.&nbsp;3.6.</b>
Радиоприемник в моей машине довольно трудно
использовать по назначению. Кроме того, почти
невозможно запомнить, как в нем устанавливаются
часы</i></caption></center></div>

<p>
Другой мой радиоприемник&nbsp;&mdash; это превосходный
электронный прибор Sony 2010 (рис.&nbsp;3.7), в котором
можно иметь 32 предварительные настройки,
закрепленные за 32 одинаковыми кнопками,
выстроенными по 8 кнопок в 4 ряда. На первый
взгляд этот радиоприемник кажется более сложным,
но, как показали мои опросы владельцев<a name="p76"></a> 
таких радиоприемников и мой
продолжительный личный опыт использования, такая
конструкция позволяет с большей легкостью найти
настройку на необходимую станцию, особенно в
темноте. Для этого следует всего лишь отсчитать
вниз ряд, в котором находится нужная кнопка, и
затем, так же отсчитав ее номер в ряду, нажать на
нее. В устройстве запоминаются все настройки,
связанные с каждой станцией, в том числе и то, в
каком диапазоне она находится (FM, AM, короткие
волны, авиадиапазон (aircraft band)) и другие
параметры, которые вы установили. При нажатии
одной из 32 кнопок все настройки, требуемые для
воспроизведения станции, устанавливаются сразу и
автоматически. Те станции, которые я слушаю чаще
всего, я закрепил за кнопками, находящимися ближе
к левому верхнему углу.</p>

<div class="image">
<center><img
src="img_3-7.jpg"><br><caption><i><b>Рис.&nbsp;3.7.</b> В
коротковолновом радиоприемнике Sony 2010 имеется
много кнопок, но можно легко и быстро научиться
пользоваться этим прибором</i></caption></center></div>

<p>
В автомобильном радиоприемнике удобство
использования жертвуется в пользу меньшего числа
кнопок и небольшого размера лицевой панели. Худшим
свойством конструкции этого приемника является то,
что для того чтобы узнать, какой из рядов
предварительных настроек сейчас активен, вы
вынуждены отрывать взгляд от дороги, иначе вы не
найдете нужной вам станции. (Чтобы переключиться с
AM на FM или наоборот, требуется найти и нажать
две кнопки, тогда как в приемнике Sony достаточно
нажать только одну кнопку, чтобы перейти на
заранее настроенную волну.)</p>

<p>
Не будет большим преувеличением сказать, что
использование модальных интерфейсов в автомобилях
должно быть запрещено. Очевидно, что мой
автомобильный радиоприемник имеет
неудовлетворительный интерфейс с точки зрения
поиска и выбора радиостанций. Еще более
неудовлетворительным является способ настройки
часов, который предусмотрен в этом радиоприемнике.
Чтобы настроить часы, мне требуется постоянно
смотреть на них: сначала необходимо нажать и
удерживать кнопку DISP в течение 2 секунд, чтобы
переключиться в режим настройки. Для выбора часа
требуется повернуть ручку настройки радиоприемника
против часовой стрелки, а для выбора минут&nbsp;&mdash; по
часовой стрелке. Чтобы закончить настройку часов,
следует нажать кнопку DISP. (Эта же кнопка служит
для регулировки громкости.) Плюсом здесь является
то, что в моих<a name="p77"></a> 
радиоприемниках по крайней мере есть
нормальные ручки для регулировки звука, а не те
кнопки, которые предназначены для этого в
некоторых более современных приборах, потому что с
помощью этих кнопок можно довольно долго
настраивать звучание на требуемую громкость, не
говоря уже о том, что текущее значение громкости
не видно на глаз и его нельзя определить на ощупь.
В пользовательском тестировании, которое я недавно
провел, каждый из 55 испытуемых предпочел для этой
роли именно ручки.</p>

<p>
<i>Меньшее число кнопок и более простой вид
лицевой панели не всегда являются лучшим
решением. Это справедливо не только для
графических интерфейсов, но и для инструментов и
приборов.</i></p>
</blockquote>

<h3>3.2.3. Режимы и квазирежимы</h3>

<p>
Использование клавиши <kbd>&lt;Caps Lock&gt;</kbd> для для набора
заглавных букв существенно отличается от
удерживания клавиши <kbd>&lt;Shift&gt;</kbd> для
той же цели. Первый случай устанавливает режим,
второй&nbsp;&mdash; нет. Ряд экспериментов, проведенных в
университете г. Торонто, подтвердил, что
удерживание кнопки в нажатом состоянии, нажатие на
ножную педаль или любая другая форма физического
удерживания интерфейса в определенном состоянии не
приводит к возникновению модальных ошибок (Sellen,
Kurtenbach и Buxton, 1992). Другие исследования
показали, что в основе этого феномена лежат
нейрофизиологические причины. Большая часть нашей
нервной системы функционирует таким образом, что
постоянный стимул порождает сигналы, которые со
временем снижают свою способность привлекать наше
внимание. Это снижение продолжается до тех пор,
пока наша когнитивная система совсем не перестает
получать никакие сигналы. Однако сигналы, которые
сообщают нам о том, производят ли в данный момент
наши мышцы усилие, не снижают уровня своего
воздействия.</p>

<p>
Включение и физическое удерживание того или иного
элемента управления во время выполнения другого
действия было названо <i>пружинным режимом</i>
(spring-loaded mode) или <i>режимом с запертой
пружиной</i> (spring-locked mode) (Johnson и
Englebeck, 1989). Но такая терминология здесь не
подходит, поскольку никакая физическая пружина
может вообще не использоваться, клавиша или кнопка
не запирается, и их удерживание не вызывает
модальных ошибок. Выражение <i>режим, удерживаемый
пользователем</i> (<i>user-maintained mode)</i>, является
более точным, но от него трудно образовать
прилагательное. Для обозначения режимов, которые
удерживаются пользователем кинестетически, я стал
использовать термин <i>квазирежим</i> и его
прилагательное <i>квазимодальный</i> (рис.&nbsp;3.8).</p>

<div class="image"> 
<center><img
src="img_3-8.jpg"><br><caption><i><b>Рис.&nbsp;3.8.</b>
Нотр-Дамский горбун</i></caption></center></div>

<p>
Квазирежимы являются весьма эффективными с точки
зрения устранения режимов (Raskin, 1989). Однако
излишнее использование квазирежимов может привести
к абсурдным условностям, требующим запоминания<a name="p78"></a> 
десятков команд, например
<kbd>Control&darr; Alt&darr; Shift&darr; Esc&darr; q&uarr;&uarr;&uarr;</kbd>. 
Для сохранения эффективности число
квазирежимов, скорее всего, должно быть от 4 до 7.
Тем не менее, необходимо сказать, что один
квазирежим может решить сразу множество различных
проблем (см. раздел 5.4).</p>

<p>
Типичная проблема, которая легко решается при
помощи квазирежимов, возникает в тех случаях,
когда интерфейс предлагает пользователю некий
набор вариантов, например выпадающее меню в
Macintosh. При таком применении квазирежимов вы
нажимаете кнопку графического устройства ввода, и,
пока вы удерживаете кнопку в нажатом положении,
под названием меню появляется список вариантов. Вы
перемещаете курсор на требуемый вариант и
отпускаете кнопку, чтобы выбрать соответствующий
пункт меню.</p>

<p>
Другим случаем применения квазирежимов является
циклический переход по некоторому списку опций.
Если цикл начинается с одного и того же элемента
списка и переход происходит в одном и том же
направлении и если в списке содержится небольшое
число элементов, то для выбора конкретной опции
потребуется только определенное число нажатий.
Например, в компьютере Canon Cat при
форматировании выделенного текста пользователь
может изменить стиль абзаца в пределах четырех
вариантов: по левому краю, по центру, по правому
краю или по ширине. Стиль абзаца определялся с
помощью повторного нажатия на клавишу с надписью
на фронтальной поверхности</p>

<p>
<kbd>&para;STYLE</kbd></p>

<p>
<a name="p79"></a>
Для того чтобы задействовать функцию клавиши,
обозначенную на ее фронтальной поверхности, в
компьютере Canon Cat была предусмотрена
специальная клавиша <kbd>&lt;Use Front&gt;</kbd> (рис.&nbsp;3.9).</p>

<p>
В общем смысле клавиша <kbd>&lt;Use Front&gt;</kbd> позволяет вам
активизировать функции, обозначенные не сверху, а
на фронтальной поверхности клавиш. Стиль абзаца
назначался в квазирежиме (вы нажали и удерживали
клавишу <kbd>&lt;Use Front&gt;</kbd>, пока нажимали кнопку
<kbd>&para;Style</kbd>), и поэтому компьютеру было ясно,
сколько раз клавиша была нажата. В результате вы
выучили, что одно нажатие выравнивало выделенный
текст по левой стороне, два нажатия&nbsp;&mdash; по правой
стороне, и т.д. Если бы цикл всегда начинался с
той опции, которая использовалась последний раз,
как это часто делается в интерфейсах, применение
команды назначения стиля абзаца не могло бы стать
привычным, и вам всегда приходилось бы смотреть на
монитор, чтобы увидеть результат команды.
Заметьте, что если бы нажатие на кнопку назначения
стиля абзаца не требовало также и удерживания
кнопки <kbd>&lt;Use Front&gt;</kbd>, это бы не работало правильно,
потому что именно удерживание кнопки <kbd>&lt;Use Front&gt;</kbd>
устанавливало квазирежим и позволяло системе
определить начало отсчета.</p>

<p>
<i>Элементы интерфейса часто можно называть
привычными в том случае, что они могут легко
использоваться &laquo;слепым&raquo; пользователем.
Интерфейсы, построенные на основе принципов,
изложенных в этой книге, часто могут
использоваться даже слепыми пользователями,&nbsp;&mdash; а
по отношению к тому, что находится вне нашего
локуса внимания, мы все являемся в самом прямом
смысле слепыми.</i></p>

<div class="image">
<center><img
src="img_3-9.jpg"><br><caption><i><b>Рис.&nbsp;3.9.</b>
Клавиша <kbd>&lt;Use Front&gt;</kbd> и некоторые другие командные
клавиши, используемые в компьютере Canon Cat.
Надпись USE FRONT имеет светло-голубой цвет, так
же как и надписи на фронтальной поверхности тех
клавиш, которые могут быть задействованы с помощью
клавиши <kbd>&lt;Use Front&gt;</kbd></i></caption></center></div>

<p>
<a name="p80"></a>
В некоторых меню или палитрах самый используемый
элемент или тот, который был использован последний
раз, помещается наверх, что является простым
примером <i>адаптивного меню</i> или <i>адаптивной
палитры</i>. Меню или палитра делаются адаптивными
исходя из того предположения, что если оставлять
часто используемый элемент на виду, без
необходимости поиска его в меню, то это может
ускорить работу пользователя. Здесь полезно
сравнить два метода. В первом методе выбранный
элемент <i>убирается</i> из общего списка и
помещается в основную палитру или меню. Во втором
методе выбранный элемент <i>копируется</i> в
основную палитру или меню (рис.&nbsp;3.10).</p>

<div class="image">
<center><img
src="img_3-10.jpg"><br><caption><i><b>Рис.&nbsp;3.10.</b>
Выдвигающаяся палитра Ашлара. Обратите внимание на
то, что первый элемент из выдвигающейся группы
дублируется в основном меню, поэтому все элементы,
группы остаются в одном и том же порядке, что
позволяет сделать их использование
автоматичным</i></caption></center></div>

<p>
Поначалу первый метод кажется лучше, потому что в
списке остается на один элемент меньше,
следовательно, пользователю придется сделать на
один выбор меньше, а места на экране становится
больше. Однако в этом случае пользователю придется
останавливаться, чтобы проверить, где именно
находится нужный ему элемент: в основном меню или
в выдвигающемся, особенно если с момента
последнего его использования прошло больше
нескольких секунд. Но второй метод, при котором
пользователь всегда знает, каким по счету является
тот или иной элемент в списке, обычно оказывается
эффективнее, поскольку с когнитивной точки зрения,
если вы помните, что и где находится в основном
меню, вы сэкономите время и не станете
просматривать весь список элементов. Но если вы не
помните, вы сможете воспользоваться списком как
обычно.</p>

<p>
Пакет Vellum (Ashlar, 1995) является примером
продукта, в интерфейсе которого грамотно
используются адаптивные палитры (рис.&nbsp;3.10).
В этом<a name="p81"></a> 
пакете палитры действительно являются
адаптивными, <i>и</i> каждый инструмент можно
найти в ожидаемом месте. Таким образом, опытный
пользователь может решить не пользоваться
адаптивным меню и автоматично отправится к тому
месту, где привычно располагается необходимый ему
инструмент. В разделе 3.5 будет рассмотрен еще
один аспект использования нескольких способов для
выбора какого-либо инструмента.</p>

<p>
Существует идея, по которой интерфейс должен
адаптироваться в соответствии с эмоциональным
состоянием пользователя, и в некоторых продуктах
(например, Bob от компании Microsoft)
действительно делается попытка приспособить
интерфейс под характеристики личности
пользователя. Однако пока непонятно, каким образом
интерфейс может подстраиваться под пользователя,
не нарушая процесса привыкания. И даже если
когда-нибудь мы и сможем уверенно определять
текущее эмоциональное состояние пользователя и
использовать эту информацию для улучшения
характеристик интерфейса, не нарушая системы
автоматичных реакций и навыков пользователя,
интерфейсы все же должны будут обладать
способностью удовлетворять те когнитивные
потребности пользователя, которые являются
неизменными. Поэтому принципы, о которых идет речь
в этой книге, могут быть применены и, вероятно,
должны быть применены еще до настройки интерфейса
в соответствии с эмоциональными потребностями
пользователя.</p>

<p>
В основном существует только два типа сигналов,
которые вы вводите в компьютер или другое
устройство для обработки информации: те, которые
служат для создания содержания, и те, которые
используются для управления системой. В этом
отношении предлагается следующий практический
подход: <i>квазирежимы должны использоваться для
управленческих функций, тогда как для создания
содержания должны применяться операции без
задействования квазирежимов</i>. Именно этот
подход можно считать наиболее верным, поскольку
управлять системой, удерживая кнопку для включения
квазирежима, труднее. Однако важнее, чтобы
пользователь мог больше времени уделить созданию
содержания и работе с ним, а не применению
различных команд для управления системой.</p>

<h2>3.3. Модели &laquo;существительное-глагол&raquo; и
&laquo;глагол-существительное&raquo;</h2>

<p>
Большой класс команд предусматривает применение
некоторого <i>действия</i> к некоторому
<i>объекту</i>. Например, при использовании
текстового процессора вы можете выбрать какой-то
абзац и изменить его шрифт. В этом случае объектом
является абзац, а действием&nbsp;&mdash; выбор нового
шрифта, при этом в интерфейсе могут использоваться
две последовательности: либо (1) сначала выбор
<i>глагола</i> (изменить шрифт), а затем выделение
<i>существительного</i> (абзац); либо (2) сначала
существительное, а потом глагол. На первый взгляд
может показаться,
что<a name="p82"></a> оба варианта являются симметричными, и порядок
не важен. Однако для большинства интерфейсов
ситуация не является симметричной, и порядок
(существительное-глагол или
глагол-существительное)<a name="r15" href="#f15"><sup>15</sup></a> имеет большое значение с
точки зрения юзабилити интерфейса.</p>

<p>
В большинстве руководств по разработке интерфейсов
рекомендуется именно модель взаимодействия
существительное-глагол (Apple, 1987; Hewlett
Packard, 1987; IBM, 1988; Microsoft. 1995).
Анализ, проведенный с точки зрения локуса внимания
пользователя, показывает преимущества такой
модели:</p>

<ul>
<li>
<p>
<i>Уменьшение количества ошибок</i>.
Последовательность глагол-существительное
устанавливает режим. Если вы выбрали команду
изменения стиля, то она будет сразу применена к
тексту, который вы выделите. Если между
назначением команды и выделением текста произойдет
задержка или внимание пользователя отвлечется, но
после того как текст будет выделен, результат
может оказаться для него неожиданным. При
использовании модели существительное-глагол
команды выполняются сразу, пока еще находятся в
локусе внимания пользователя.</p>

<li>
<p>
<i>Скорость</i>. Пользователю не требуется
переключать свое внимание с содержания (которое и
вызвало необходимость выполнения операции) к самой
команде и затем опять к содержанию, чтобы можно
было выделить необходимый участок текста. В модели
существительное-глагол вы сначала выделяете текст,
находящийся в локусе вашего внимания, и затем
переключаете внимание на команду. Таким образом,
число переключений локуса внимания уменьшается на
единицу.</p>

<li>
<p>
<i>Простота и обратимость</i>. При
использовании модели глагол-существительное должна
быть предусмотрена возможность отмены или отката
команды. Если пользователь назначает команду и
затем решает изменить ее, следует учитывать, что
он находится в этот момент в режиме, и система
ожидает, что будет сделано выделение текста для
применения уже назначенной команды. Поэтому должен
быть предусмотрен механизм подачи системе сигнала
о том, что вы не хотите выделять текст и хотите
назначить другую команду. В модели
существительное-глагол, для того чтобы выбрать
другой текст, не требуется нажимать кнопку отката
или применять какой-либо другой способ отмены
действия.</p>
</ul>

<p>
Тем не менее, в каждом из увиденных мной
руководств по разработке интерфейсов, в которых
рекомендуется модель существительное-глагол,
использование модели глагол-существительное также
допускается. В руководстве Microsoft говорится,
что модель глагол-существительное необходимо
использовать для палитр, например, в выборе стиля
кисти<a name="p83"></a> в графических редакторах (Microsoft, 1995).
Вообще, это не совсем правильно. В данном случае
также можно использовать чистую модель
существительное-глагол. Вы можете рисовать с
использованием набора параметров, принятого по
умолчанию (например, тонкая линия черного цвета),
и затем с помощью команд изменять цвет, ширину,
текстуру и другие параметры линии. Однако на самом
деле мы хотим сразу видеть, как выглядит каждый
мазок, который мы делаем, со всеми его
параметрами.</p>

<p>
Общепринятый способ, при котором пользователь
сначала выбирает атрибуты из одной или нескольких
палитр,&nbsp;&mdash; аналогично тому, как вы можете перед
началом рисования макать кисть в ту или другую
банку с краской,&nbsp;&mdash; приводит к модальным ошибкам,
которые, как мы уже видели, неизбежно должны здесь
возникать. Имеет смысл делать так, чтобы выбранный
режим сохранялся до тех пор, пока пользователь
специально не сменит его. В этом случае вы можете
начать рисование и неожиданно обнаружить, что для
этого используются другие атрибуты, но, к счастью,
результат рисования в данный момент находится в
локусе вашего внимания. Программное обеспечение,
которое в нашей терминологии мы можем назвать
человекоориентированным, в этом случае позволит
вам сразу отменить не устраивающий вас результат,
изменить атрибуты и продолжить работу. Модальные
ошибки всегда вызывают раздражение, поэтому модель
существительное-глагол или другой немодальный
метод был бы более эффективным в этой ситуации, но
пока, насколько я знаю, никто еще не нашел
удачного решения этой проблемы.</p>

<p>
<i>В целом, подход &laquo;существительное-глагол&raquo;
является более предпочтительным. Применение
методов &laquo;глагол-существительное&raquo; должно
ограничиваться только выбором из палитр, если они
предназначены для непосредственного
использования.</i></p>

<blockquote>
<p>
<b>Пример приведения проблемной модели
&laquo;глагол-существительное&raquo; к модели
&laquo;существительное-глагол&raquo;</b></p>

<p>
Работники разных отделов одной транснациональной
корпорации использовали специальную компьютерную
систему для размещения заказов на товары. На ее
примере мы рассмотрим один из способов перехода с
естественной, на первый взгляд, модели
&laquo;глагол-существительное&raquo; на модель
&laquo;существительное-глагол&raquo;. Такое изменение
помогло на практике устранить те ошибки, которые
возникали при использовании первого варианта
интерфейса, и ускорило процесс выполнения заказа
на товары.</p>

<p>
В исходном варианте процесс состоял из трех шагов:</p>

<ol>
<li>
<p>
Необходимо выбрать отдел, для которого заказ
был предназначен. Для этого следовало поставить
флажок рядом с названием отдела. Один из флажков,
соответствующий отделу, в котором находился данный
компьютер, был установлен по умолчанию.</p></li>

<li>
<p>
Требовалось выбрать необходимые товары из
прокручиваемого списка. Рядом с каждым товаром
находилось текстовое окно ввода, в которое можно
было занести заказываемое количество каждого
товара.</p></li>

<li>
<p>
Необходимо щелкнуть по одной из двух кнопок
внизу дисплея: либо &laquo;Отменить заказ&raquo;, либо
&laquo;Подтвердить заказ&raquo;.</p></li>
</ol>

<p>
Первая проблема состояла в том, что пользователи
не могли выбрать свой отдел, если они делали заказ
не со своего рабочего места. Разработчики компании
предложили отменить установку отдела по умолчанию,
вынуждая пользователей каждый раз сначала выбирать
отдел. Они заметили, что в этом случае единственно
возможная ошибка связана только с выбором
неправильного отдела. Тем не менее, такое решение
раздражало тех пользователей, которые обычно
работали за своим компьютером, и необходимость
каждый раз вводить информацию, которая уже была
доступна системе, вызывала раздражение.</p>

<p>
По сути дела, проблемой являлась все та же
ситуация &laquo;глагол-существительное&raquo;. Сначала
необходимо было ввести, что вы хотите сделать
(доставить эти товары в этот отдел), и затем
выбрать, что именно вы хотите доставить. Однако
при открытии окна заказа в локусе вашего внимания
находятся (или только что находились) товар или
товары, которые вам нужны.</p>

<p>
Часть решения заключалась в том, чтобы разместить
список товаров наверху окна заказа. Таким образом,
пользователь мог начать с выделения нужных
товаров. А список отделов, который раньше не имел
никаких надписей, получил заголовок в форме
вопроса: &laquo;В какой отдел следует доставить
заказанные товары?&raquo;</p>

<p>
Если система могла определить собственный отдел
пользователя (на основе журнала работы
пользователя), в первую строку списка отделов
автоматически добавлялся элемент под названием
&laquo;Мой отдел&raquo;, который так же, как и другие
элементы списка, имел флажок.</p>

<p>
Все другие отделы, расположенные в алфавитном
порядке, составляли остальную часть списка. Рядом
с каждым отделом находился флажок. При установке
флажка появлялось сообщение: &laquo;Отмеченные товары
заказаны&raquo;, которое исчезало сразу после любого
действия пользователя.</p>

<p>
В измененном варианте интерфейса выбор отдела
являлся действием, т.е. глаголом, после которого
информация об отмеченных товаpax<a name="p85"></a> 
отправлялась для обработки. Психологически это
стало действием, завершающим всю операцию заказа,
а не предваряющим его. Кроме того, следует
отметить, что к этому моменту бланк заказа уже
заполнен, и внимание пользователя сместилось с
самих товаров на необходимость их доставки. Таким
образом, ход работы стал соответствовать тому,
куда обычно следует внимание пользователя.</p>

<p>
Отпала необходимость в установке места доставки по
умолчанию, так как интерфейс предоставлял четкое
психологическое окончание процессов выбора товаров
и отправки заказа. В начальном варианте интерфейса
требовалось подтверждение заказа, тогда как в
новом варианте количество щелчков мыши
сократилось, ибо от пользователя не требовалось
делать еще одного лишнего щелчка. С введением
нового варианта интерфейса у пользователей
появилась возможность сформировать привычку
выбирать из списка отделов обычное место доставки,
но оставалась вероятность того, что пользователь в
редких случаях мог забыть отметить при
необходимости и другие отделы, в которые товары
должны быть доставлены. Тем не менее, даже с
наличием этой потенциальной ошибки новый вариант
интерфейса был существенно улучшен по сравнению с
предыдущим.</p>
</blockquote>

<h2>3.4. Видимость и состоятельность</h2>
		<div class="epigraph"><blockquote><p>На пустом диске ты можешь искать
		бесконечно долго.</p>
		<cite>Источник
		неизвестен</cite></blockquote>
		</div>

<p>
Независимо от того, чем является продукт&nbsp;&mdash;
переносным двухполосным радиоприемником или
рабочим столом экрана компьютера, не всегда ясно,
какие именно функции сейчас доступны, что они
выполняют и как получить к ним доступ.
Пользователь должен применять собственные органы
чувств для того, чтобы определять, какие функции
сейчас доступны и каким образом их можно
использовать.</p>

<p>
Элемент интерфейса можно считать <b>видимым</b>, если он
либо в данный момент доступен для органов
восприятия человека (обычно это глаза, но здесь
также рассматриваются и другие сенсорные
модальности), либо он был настолько недавно
воспринят, что еще не успел выйти из
кратковременной памяти пользователя. Если элемент
интерфейса не видим, то мы говорим, что он
<b>невидимый</b>. Для нормальной работы интерфейса
&laquo;должны быть видимы только необходимые вещи&nbsp;&mdash;
те, что идентифицируют части работающих систем, и
те, что отображают способ, которым пользователь
может взаимодействовать с устройством. Видимость
отображает связь между предпринимаемыми действиями
и их реальной отдачей&raquo; (Norman, 1988, с.&nbsp;8).<a name="r16" href="#f16"><sup>16</sup></a>
Если интерфейс вынуждает вас запоминать
существование того или иного его элемента, это
означает, что этот элемент является невидимым.
Если вы вынуждены углубляться в недра интерфейса,
чтобы случайно или в результате собственной
настойчивости натолкнуться на последовательность
действий,<a name="p86"></a> 
которая активизирует какой-то его элемент,
то этот элемент является невидимым. Если вам
приходится обращаться за помощью к справочной
системе для того, чтобы узнать, как выполнить то
или иное действие, это означает, что методы
выполнения этого действия невидимы. Многие
компьютерные игры являются, по сути дела,
недокументированными интерфейсами, в которых
способы управления или пути достижения желаемых
результатов невидимы. Стоит добавить к этим играм
документацию, и они станут неинтересными. Однако
<i>большинство людей не хотят играть в игры, когда
им требуется выполнить свою работу, поэтому перед
разработчиком интерфейсов стоит задача сделать
каждый элемент своего продукта видимым</i>.</p>

<p>
Если в интерфейсе соблюдается принцип видимости,
то каждая функция и способ ее использования для
большинства людей из той культуры, на которую этот
интерфейс ориентирован, становятся очевидными
только лишь по одному виду. Элемент управления,
который имеет такое свойство, стали называть
<b>состоятельным</b> (affordance) (Norman, 1988, с.&nbsp;123).
&laquo;Состоятельность является хорошим средством для
связки элемента интерфейса с его целью. Ручки
используются для настройки; гнезда&nbsp;&mdash; для вставки
чего-то; мячи&nbsp;&mdash; для их бросания или пинания&raquo;
(Norman, 1988, с.&nbsp;9). Если вы как разработчик
помещаете в какой-то продукт ручку, подобную тем,
с помощью которых регулируется громкость,
пользователи будут пытаться ее крутить. Если вы
поместите что-нибудь, наподобие кнопки,
пользователи будут пытаться на нее нажимать. То,
какую состоятельность будет иметь элемент
интерфейса, зависит от опыта и знаний
пользователя, а также от контекста, в котором он
этот элемент встречает.</p>

<p>
При анализе интерфейсов следует всегда спрашивать
себя, каким образом пользователь может узнать, что
то или иное действие возможно; также следует
всегда стремиться к тому, чтобы каждый видимый
элемент был состоятельным. Пиктограммы часто
рассматриваются как символические обозначения
состоятельности, но, как мы выясним в разделе 6.3,
они не всегда выполняют эту функцию.</p>

<p>
Видимость означает не просто возможность заметить
наличие. Любой объект может быть видимым в том
смысле, что он может быть обнаружен в определенном
месте, но при этом он может быть очень небольшим
по размеру или иметь небольшой контраст с фоном,
чтобы быть легко замеченным. Оптимизация качества
восприятия интерфейса является важным аспектом с
точки зрения эргономики, и основное значение здесь
имеют когнитивные свойства интерфейса.</p>

<blockquote>
<p>
<b>Система BART и отсутствие состоятельности</b></p>

<p>
Упоминание в этой книге системы BART (Bay Area
Rapid Transit)<a name="r17" href="#f17"><sup>17</sup></a> связано с интерфейсом, который
используется автоматами по продаже билетов. Эти
автоматы являются результатом игнорирования
администрацией 25-летнего опыта работы старых
роботов по продаже билетов. Пока я стою в очереди
к одному из двух еще не сломавшихся автоматов, я
замечаю, как подходящие люди приходят в
замешательство при виде этого устройства. Хотя у
меня довольно большой опыт пользования разными
устройствами, но мне самому не удается справиться
с той неестественной последовательностью действий,
которая требуется для применения этих билетных
автоматов.</p>

<p>
Очевидно, что для того чтобы начать взаимодействие
с автоматом, сначала требуется опустить в него
деньги или старый билет, который является денежным
эквивалентом необходимой суммы,&nbsp;&mdash; что и пытался
в первую очередь сделать почти каждый во время
моего наблюдения. Обычно автоматы по продаже
работают так: опускаешь деньги, выбираешь,
получаешь. Такой подход стал парадигмой.</p>

<p>
Автоматы по продаже билетов системы BART,
наверное, были изобретены на другой планете.
Сначала вам необходимо нажать на одну из двух
кнопок: либо BART, либо BART-MUNI. (В инструкции,
которую трудно найти где-то поблизости,
объясняется весьма тонкое различие между этими
двумя кнопками.) Эти кнопки расположены в верхней
части передней панели автомата. Место, конечно,
вполне разумное для начала взаимодействия, в
отличие от самого действия, которое для этого
используется. Щели для старого билета (слева), для
монет (посередине) и для бумажных купюр (справа)
находятся на большом расстоянии друг от друга
вместо того, чтобы быть расположенными в одном
месте. Жидкокристаллический дисплей находится по
центру высоко вверху, поэтому люди невысокого
роста не могут легко прочитать возникающие
сообщения. В любом случае он находится настолько
далеко от основной части интерфейса, что
большинство людей его просто не замечает.
Возможно, это даже и хорошо, потому что время его
отклика настолько большое, что люди, которые
все-таки смотрят на него, или пытаются повторить
операцию, или стоят в недоумении, предполагая, что
автомат сломался, что, кстати, часто бывает.</p>

<p>
Кроме этого, есть кнопка &laquo;поправка&raquo;
(correction). Ее название наводит на мысль, что
использовать ее следует в случае, если вы сделаете
какую-то ошибку. Но на самом деле она
предназначена совсем не для исправления ошибок, а
для того чтобы получить билет на сумму меньшую,
чем та, которую вы опустили в автомат. Другими
словами,<a name="p88"></a> 
с помощью этой кнопки вы можете сказать
машине, что хотите получить сдачу.</p>

<p>
Другим признаком того, что автомат разработан
плохо, являются яркие крупные цветные числа 1, 2,
3, 4 и большие стрелки, которые, как кажется,
должны как-то инструктировать вас. Если бы лицевая
панель автомата была спроектирована грамотно, то
вам бы они не понадобились. Числа в любом случае
нисколько не помогают, поскольку во время
опускания в автомат денег ($5) вам все равно надо
помнить, какой шаг вы сейчас выполняете (например,
шаг 2). Если же вам нужен билет за $3, то нужно
еще не забыть нажать кнопку &laquo;поправка&raquo;, чтобы
получить сдачу в виде четвертаков (8 шт.), и тут
вы слышите, что прибывает поезд на 7:06. Так, а на
каком, вы сказали, мы сейчас шаге? Если вы
встречаете компьютерный интерфейс, в котором есть
много ярких красок и мириады объяснительных
надписей, можете быть уверены, что он представляет
собой сплошную путаницу.</p>

<p>
Автоматы BART могли бы работать, например,
следующим образом. (Однако имейте в виду, что если
бы вы консультировали компанию BART, то
потребовалось бы провести пользовательское
тестирование (юзер-тестинг) вашего варианта, чтобы
убедиться, что люди пользуются им именно так, как
вы и предполагали.)</p>

<p>
Слева (т. к. английский и испанский языки читаются
слева направо) располагается щель для старых
билетов, горизонтальная щель для банкнот и
небольшая вертикальная щель для монет. Все они
сгруппированы в одном месте и имеют понятные
надписи. На дисплее, размещенном на уровне глаз
человека среднего роста, отображается сообщение:
&laquo;Опустите в автомат деньги ИЛИ старый билет
системы BART ИЛИ и то и другое&raquo;. После этого на
экране <i>сразу же</i> появляется общая сумма в
виде следующего сообщения:</p>

<blockquote>
<p>
Вы опустили $4.55.</p>

<p>
Если вам нужен билет стоимостью больше, чем $4.55,
опустите дополнительную сумму денег или еще один
использованный билет.</p>

<p>
Если вам нужен билет стоимостью меньше, чем $4.55,
нажмите клавишу:</p>

<p>
<u>Получить сдачу с билета</u></p>

<p>
Если вам нужен билет стоимостью $4.55, нажмите
одну из следующих клавиш:</p>

<p>
<u>Выдать билет BART</u></p>

<p>
<u>Выдать билет BART-MUNI</u></p>
</blockquote>

<p>
Если пользователь нажмет кнопку &laquo;Получить
сдачу&raquo;, то ему будет задан вопрос о том, на какую
сумму он хочет купить билет, после чего
потребуется нажать кнопку ENTER, находящуюся под
числовой
клавиатурой.<a name="p89"></a> После этого на экране отобразится
текущая сумма, которую следует либо увеличить,
либо уменьшить, либо подтвердить. После выдачи
билета пользователю должна быть возвращена сдача.
Если опытный пассажир уже имеет точную сумму
денег, то для него количество действий сокращается
с шести до следующих двух: опустить деньги и
нажать кнопку &laquo;Выдать билет&raquo;.</p>
</blockquote>

<h2>3.5. Монотонность</h2>
		<div class="epigraph"><blockquote><p>Человек&nbsp;&mdash; слишком сложный организм. Если уж
		ему суждено исчезнуть, то вымрет он от желания
		простоты.</p>
		<cite>Эзра Паунд</cite></blockquote>
		</div>

<p>
Разработчики интерфейсов часто предлагают
пользователям сразу несколько методов достижения
того или иного результата. Например, одна и та же
команда может выполняться как с помощью меню, так
и с помощью сочетания клавиш. В большинстве
текстовых процессоров вы можете переместить
фрагмент текста либо за три шага (выделение,
вырезание, вставка), либо за два (выделение и
перетаскивание). Причем сам процесс выделения
может выполняться более чем одним способом. Таким
образом, для пользователя обычно имеется целый
&laquo;шведский стол&raquo; методов.</p>

<p>
Одним из оправданий такого разнообразия методов
для выполнения задачи может быть то, что одни
пользователи могут предпочесть один метод, а
другие пользователи&nbsp;&mdash; другой. Например, для
новичка научиться пользоваться меню может быть
легче, тогда как опытный пользователь, скорее
всего, не будет отрывать рук от клавиатуры и
отдаст команду с ее помощью (см. раздел 3.6).
Другим оправданием может быть то, что один метод
(например, выделение, вырезание и вставка) может
быть полезным для работы с разнесенными частями
документа, а другой метод (выделение и
перетаскивание) может быть эффективным, только
когда на дисплее видны и исходная и конечная
позиции одновременно. Другим обоснованием
множества методов может быть то, что каждый из них
порожден традицией, и поэтому разработчики считают
разумным использовать как можно больше навыков из
уже существующих у пользователей.</p>

<p>
Этот последний довод, называемый еще <i>обратной
совместимостью</i> (backward compatibility)<a name="r18" href="#f18"><sup>18</sup></a>,
является самым слабым и может привести к абсурдным
интерфейсам в виде собрания несовместимых методов.
Однажды во время одного из длинных авиаперелетов
нам пришлось приземлиться из-за плохой погоды.
Пока мы ждали ее улучшения, я прошел в кабину
пилотов, где смог изучить устройство автопилота. В
нем
имелось<a name="p90"></a> не менее пяти способов для ввода координат
и столько же способов для включения большинства
его функций. Когда я спросил пилота о причинах
такой избыточности, она ответила, что автопилот
сделан таким образом, чтобы функционально быть как
можно более подобным автопилотам на других
самолетах, на которых пилоты могли изучать данный
прибор и тем самым избежать необходимости
переучивания. Однако возникал вопрос относительно
того, насколько такой подход можно считать
правильным и насколько точно выполняется
дублирование других автопилотов. Как она мне еще
объяснила, пилоты должны изучать не только те
небольшие, но, тем не менее, раздражающие различия
между старой системой автопилота и ее эмуляцией на
новой модели, но также и остальные четыре способа
использования автопилота. То есть пилот обязан
знать <i>каждый</i> аспект работы <i>каждого</i>
элемента оборудования пилотской кабины. Более
того, следует отметить, что многие новые функции
автопилота имеются только в некоторых эмуляциях, и
ранние модели автопилотов не содержат этих
функций, т.к. и копируемые автопилоты их не
имели.</p>

<p>
Тактика гибридизации различных вариантов
интерфейса, а вернее, сбрасывания всех методов
подряд в одну кучу увеличивает время обучения,
создает сложный в использовании автопилот и, как
отметила упомянутый пилот, &laquo;создает путаницу в
кабине и увеличивает вероятность ошибки&raquo;. Хотя
она и не сказала этого, но, вероятно, это также
увеличивает стоимость и сложность приборов,
руководств по их использованию и стоимость их
обслуживания. То же касается любого интерфейса,
который представляет собой совокупность
разрозненных подходов, накопленных с течением
времени, включая также Macintosh и Windows.</p>

<p>
Для описания интерфейса, имеющего только один
способ выполнения той или иной задачи, я использую
термин <i>монотонный</i>, который все же не совсем
удачен (см. приложение B, а также Alzofon и
Raskin, 1985, с.&nbsp;95). <b>Монотонность</b>&nbsp;&mdash; это
вторая сторона отсутствия модальности. В
интерфейсе, который не имеет режимов, данный жест
пользователя может иметь один и только один
результат: жест <var>g</var> всегда приводит к
действию <var>a</var>. Тем не менее, вполне возможно,
что другой жест <var>h</var> тоже может приводить к
результату в виде действия <var>a</var>. Однако
монотонный интерфейс допускает только один способ
выполнения того или иного действия, т.е. в этом
случае действие <var>a</var> может вызываться только
лишь жестом <var>g</var> и более никаким другим.
Интерфейс, который является полностью немодальным
и монотонным, допускает только одно соответствие
между причиной (командами) и следствием
(действиями). Чем более монотонным является
интерфейс с точки зрения пространства данной
задачи, тем легче для пользователя сформировать
автоматичность ее выполнения, которая, в конце
концов, создается тем, что снимается необходимость
выбирать способ достижения результата.</p>

<p>
Другой причиной отсутствия монотонности в
интерфейсе может быть нерешительность
разработчиков. Я встречал случаи, когда проблема
наличия каких-то двух и более вариантов, ни один
из которых не имеет преимуществ по сравнению с
другими, предусмотрительно &laquo;решалась&raquo; с помощью
внедрения сразу <i>всех</i> этих вариантов. В
пользу такого подхода обычно приводится довод о
том, что пользователь в этом случае получает
выбор, как будто бы пользователь является
экспертом по интерфейсам и может сам выбрать самый
эффективный вариант.</p>

<p>
Общераспространенным мифом (более подробно о нем
см. в разделе 3.6) является то, что интерфейсы для
начинающих и опытных пользователей системы должны
быть совершенно различными. Иногда разработчики
говорят о том, что &laquo;необходимо найти компромисс
между легкостью изучения интерфейса и общей
скоростью работы системы&raquo; (Card, Moran, и Newell,
1983, с.&nbsp;419). Это действительно может касаться
каких-то особых моделей интерфейсов, но это
необязательно имеет отношение ко всем интерфейсам
вообще и в частности к тем видам интерфейса,
которые обсуждаются в этой книге. <i>Современные
графические пользовательские интерфейсы, имеющие
рабочий стол, являются сочетанием, по крайней
мере, двух разных интерфейсов: с одной стороны,
сравнительно видимой и быстроизучаемой системы на
основе меню, а с другой&nbsp;&mdash; неполного собрания
трудноизучаемых и труднозапоминаемых комбинаций
клавиш. Сочетание двух ошибок не может дать
правильного ответа.</i></p>

<p>
Когда требуется сделать выбор между несколькими
методами, ваш локус внимания временно смещается с
текущей задачи на принятие решения о выборе. Это
является главным обоснованием монотонности
системы. Если условия для принятия решения
остаются достаточно простыми и ясными, то в каждом
случае вы можете поступать неким привычным
способом, тем самым делая ситуацию &laquo;монотонной&raquo;.
Таким образом, перед разработчиками интерфейсов
стоит задача по поиску монотонного решения для
того, чтобы обеспечить такие преимущества, как
легкость изучения, простоту внедрения, минимум
документации и небольшой размер расходов на
обслуживание. Эти преимущества могут быть
достигнуты либо без затрат для разработчика, либо
за счет относительно небольшой единовременной
затраты на тщательную разработку и тестирование
интерфейса. Монотонность означает не то, что с
каким-то содержанием нельзя работать разными
способами, а то, что для вызова одной и той же
команды не должно использоваться множество жестов.</p>

<p>
Монотонность проявляется спонтанно. Многие
пользователи сами делают интерфейс монотонным
через предпочтение какого-то одного метода и
игнорирование его альтернатив независимо от
ситуации. Опытные пользователи, которые гордятся
знанием каждого закоулка какой-то системы, часто
называют таких пользователей &laquo;чайниками&raquo;. Тем не
менее, такие &laquo;чайники&raquo; могут использовать
интерфейсы более эффективно, чем
&laquo;профессионалы&raquo;. С точки зрения разработчика такие<a name="p92"></a> 
пользователи попусту теряют преимущества
других способов, но с точки зрения пользователя
оказывается, что это именно разработчики впустую
тратят свои ресурсы.</p>

<p>
<i>На мой взгляд, интерфейс, который не имеет
режимов и является&nbsp;&mdash; насколько это возможно&nbsp;&mdash;
монотонным, был бы чрезвычайно удобным в
использовании при условии, что все другие
характеристики имеют, по крайней мере, нормальное
качество, принятое для современных
интерфейсов.</i> Применяя такой интерфейс,
пользователь смог бы сформировать необычайно
высокий уровень доверия к собственным привычкам.
Только в результате этих двух свойств мог бы
возникнуть эффект исчезновения интерфейса из
сознания пользователя, предоставляя ему
возможность направить все свое внимание на текущую
задачу. Чтобы изучить все психологические свойства
системы, являющейся монотонной и полностью (или
почти полностью) лишенной режимов, требуется
провести еще множество экспериментальных
исследований.</p>

<p>
<i>Если я прав, то использование продукта,
интерфейс которого основан на немодальности и
монотонности, могло бы быстро вызывать привыкание
(близкое к зависимости) у пользователей, приводя к
тому, что все они могут приобрести преданность
этому продукту и предпочитать его всем другим.</i>
Для пользователей такого продукта оказалось бы
психологически трудным перейти к применению
конкурирующего продукта. В отличие от продажи
наркотиков, продажа интерфейсов, вызывающих
привыкание у их пользователей, не является
противозаконной, а сам интерфейс приносит
пользователям облегчение. С другой стороны, это
все же имеет сходство с продажей наркотиков в том,
что может приносить такие же сверхвысокие доходы.</p>

<h2>3.6. Миф о дихотомии &laquo;новичок-эксперт&raquo;</h2>
		<div class="epigraph"><blockquote><p>В первую очередь мы люди, а потом,
		уже либо эксперты, либо новички.</p>
		<cite>Клиффорд Насс,
		программа радио СВС &laquo;Quirks and Quarks&raquo; (Выходки
		и кварки) от 23 января 1994&nbsp;г.</cite></blockquote>
		</div>

<p>
Мнение психолога Клиффорда Насса аналогично
мнению, которое имеет автор этой книги: разработка
интерфейса должна начинаться с учета слабых и
сильных сторон человека. Каждый элемент интерфейса
должен соответствовать как нашим когнитивным
способностям, так и требованиям задачи, стоящей
перед пользователем, хотя этим требования к
разработке не исчерпываются. Мнение Насса также
отражает распространенный взгляд, суть которого
заключается в том, что всех пользователей можно
разделить на две группы: экспертов и новичков (и,
вероятно, еще тех, кто временно находится на
переходной стадии от одной группы к другой). Эта
дихотомия неверна. Как пользователь сложной
системы вы не являетесь ни новичком, ни экспертом,
и вас нельзя отнести к какой-то точке на
одномерном диапазоне<a name="p93"></a> 
между этими двумя полюсами. Вы можете знать или
не знать каждый элемент интерфейса или каждый
набор связанных элементов, которые работают
одинаковым образом. Вы можете знать, как
использовать многие команды и опции какого-то
программного пакета,&nbsp;&mdash; вы даже можете работать с
этим пакетом профессионально, и поэтому другие
люди могут обращаться к вам за советом по его
использованию. Однако вы можете не знать, как
пользоваться некоторыми другими командами, или
вообще не знать о существовании этих команд или
даже целых категорий команд в данном пакете.
Например, пользователю программы для обработки
фотоизображений, который применяет ее только для
создания онлайновых изображений, может никогда не
понадобиться возможность выполнения цветоделения,
которая используется, главным образом, для
коммерческой печати (или он может даже и не знать
об этой возможности).</p>

<p>
Разработчики интерфейсов делали разные попытки
учесть допущение о том, что пользователей можно
разделить на новичков и экспертов. Но поскольку
это допущение неверно, все эти попытки,
естественно, провалились. Хорошим примером могут
послужить адаптивные системы, способные
автоматически переключаться с режима для
начинающих пользователей в режим для опытных
пользователей, когда они определяют, что ваше
умение владеть системой достигло необходимого
уровня. Если во время использования этой системы в
режиме для начинающих пользователей она внезапно
переключается в &laquo;экспертный режим&raquo;, для
пользователя происходит неожиданное изменение
рабочей среды, по крайней мере, ее части. Не
лучшим вариантом является и то, если система будет
переключаться постепенно, часть за частью. В этом
случае она будет проявлять себя неустойчиво и
беспорядочно, поскольку привычки и навыки, которые
вы успели вчера сформировать как новичок,
становятся бесполезными, если сегодня данный
элемент переключился в экспертный режим.</p>

<p>
Однажды я встретил работающую в сети программу, в
которой была предусмотрена возможность перехода на
экспертный режим, если вам удалось хотя бы раз
успешно ею воспользоваться. Если вы не работали с
этой программой более шести месяцев, то
автоматически возвращались обратно к статусу
новичка. Конечно, любая такая схема может не
соответствовать реальной способности пользователя
учиться и запоминать. Если программа, которая
продвинула вас на более высокий уровень, после
слишком короткого периода времени переключилась
обратно в режим для новичков, необходимость опять
пользоваться методами, предусмотренными для
начинающих, вызовет у вас раздражение. Если же
программа не переключится в режим для начинающих
вовремя, то перед вами могут оказаться элементы,
использование которых вами уже прочно забыто. При
современной технологии система не может точно
определить, когда вы забыли, как пользоваться
данной возможностью, поэтому она не может точно
переключиться обратно в режим для новичков. Если
же программа будет постоянно время
от<a name="p94"></a> времени оценивать ваш уровень владения
системой, это будет назойливым для пользователя.</p>

<p>
Большинство попыток сделать интерфейс адаптивным
оказываются неблагоразумными. Всякий раз, когда
система автоматически как-то изменяется, даже если
эти изменения настолько же незначительны, как и,
скажем, измененный порядок элементов в меню, ваши
ожидания от работы системы не оправдываются, и
накопленные привычки и навыки теряют смысл.
(Кстати говоря, в своей новой операционной системе
Windows 2000 компания Microsoft представила
адаптивные меню.<a name="r19" href="#f19"><sup>19</sup></a>) С другой стороны, не существует
теории о том, что один и тот же неизменный
интерфейс не может служить хорошо в течение всего
времени использования, начиная от начального
уровня и заканчивая профессиональным. Лучшим
вариантом было не менять ничего в течение всего
времени использования продукта, и, наверное, не
следует проводить специальных исследований для
того, чтобы убедиться, что для выполнения какой-то
задачи лучше изучать только один интерфейс, а не
несколько.</p>

<p>
Очень легко попасть в ловушку идеи разработки
разных интерфейсов для разных классов
пользователей, потому что она чревата слишком
большими обобщениями, которые могут привести к
ложному упрощению процесса разработки. Немногие из
этих обобщений окажутся верными для каждого
пользователя в любом (значительно большем) классе
пользователей, который можно выделить. Средством
против такого заблуждения может быть взгляд на
интерфейс не с точки зрения класса пользователей,
а с точки зрения индивида. Каждый человек, который
использует какое-то программное обеспечение
достаточно долгое время, проходит через
сравнительно короткий этап изучения каждой команды
и каждого элемента интерфейса, а также через
намного более длительный период обычного (и,
надеюсь, автоматичного) его использования. Нам
действительно необходимо разрабатывать такие
системы, которые легко изучить и понять, но еще
более важным является то, чтобы эти системы могли
эффективно использоваться в течение длительного
времени. Исключение могут составить только
программы, которые предполагается использовать
недолго, поэтому каждый ее пользователь будет
начинающим, и вопрос приобретения навыков и
привычек здесь не имеет значения. В качестве
примера такого интерфейса можно привести
выставочный киоск, оснащенный компьютером.</p>

<p>
Фаза изучения работы элемента интерфейса требует
сознательного внимания. Поэтому простота и ясность
функции, а также ее видимость<a name="p95"></a> 
имеют особую важность. Фаза
профессионального владения интерфейсом главным
образом характеризуется бессознательным
использованием его возможностей. Такое
использование подкрепляется следующими качествами
интерфейса: соответствие задаче, немодальность и
монотонность. Эти требования ни в коей мере не
противоречат друг другу. Таким образом, <i>хорошо
разработанный, человекоориентированный интерфейс
совсем не требует разделения на подсистемы. для
новичков и экспертов</i>.</p>

<p>
Конечно, это не значит, что интерфейс не может
быть разделен на такие части. Однако если вы
разрабатываете интерфейс и у вас возник соблазн
создать комбинации клавиш специально для опытных
пользователей, подумайте, не следует ли вместо
этого переработать существующий метод так, чтобы
его механизм мог подойти под требования всех
пользователей.</p>

<p><a name="f10" href="#r10"><sup>10</sup></a>
Мне не известно, как долго термин <i>режим</i>
используется при описании интерфейсов. Во
внутреннем отчете компании Xerox, посвященном
системе Gypsy Typescript System, с гордостью
заявлялось: &laquo;В Gypsy нет <i>режимов</i>&raquo; (Tesler
and Mott, 1975). На самом деле в Gypsy
существовали режимы, но наиболее проблемные из
тех, что встречались в текстовых процессорах того
времени, были устранены. В 1975 году термин
<i>режим</i> в этом контексте был настолько новым,
что авторы даже посчитали нужным заключить его в
кавычки.</p>

<p><a name="f11" href="#r11"><sup>11</sup></a>
Уже во время написания этой книги разработчики
AutoCAD лицензировали технологию, которая
использовалась в Drafting Assistant.</p>

<p><a name="f12" href="#r12"><sup>12</sup></a>
На компьютере Macintosh соответствующая клавиша
названа более точно, Delete (удалить).</p>

<p><a name="f13" href="#r13"><sup>13</sup></a>
Я был в шоке, обнаружив кнопку питания с задней
стороны системного блока на компьютере Canon Cat,
когда его первые экземпляры пришли из Японии.
Когда я указывал на то, что в технической
документации эта кнопка даже не упоминается, в
ответ я многократно получал от инженеров только
одно-единственное объяснение: &laquo;Мы думали, что в
технических требованиях содержалась ошибка&raquo;.</p>

<p><a name="f14" href="#r14"><sup>14</sup></a>
Благодарю компанию John Fluke Manufacturing Со.
за предоставленный экземпляр прибора.</p>

<p><a name="f15" href="#r15"><sup>15</sup></a>
Также используются другие термины:
<i>объект-действие</i> и <i>действие-объект</i>.</p>

<p><a name="f16" href="#r16"><sup>16</sup></a>
Книгу <i>&laquo;The Psychology of Everyday Things&raquo;</i>
(<i>Психология каждодневных вещей</i>) можно назвать
классическим трудом, с которым следует
ознакомиться каждому.</p>

<p><a name="f17" href="#r17"><sup>17</sup></a>
Система обеспечения автобусного и
железнодорожного сообщения в Сан-Франциско.&nbsp;&mdash; <i>Примеч. науч. ред.</i></p>

<p><a name="f18" href="#r18"><sup>18</sup></a>
Я всегда говорю, что если из этого выражения
убрать слово &laquo;совместимость&raquo; (compatibility),
его истинное значение сразу становится понятным.</p>

<p><a name="f19" href="#r19"><sup>19</sup></a>
Когда я писал этот раздел, операционная система
Windows 2000 была новым продуктом, и поэтому я
смог поговорить только с несколькими ее
пользователями. Типичным отзывом было
высказывание: &laquo;Сначала адаптивные меню казались
неплохой идеей, но как только я столкнулся с тем,
что какое-то меню изменилось, это меня выбило из
колеи. Больше мне эта идея не нравится.&raquo;</p>

	<div class="page">
	<p class="back"><a href="chapter2.html">&lt;=&nbsp;Previous</a></p>
	<p class="next"><a href="chapter4.html">Next&nbsp;=&gt;</a></p>
	</div>

