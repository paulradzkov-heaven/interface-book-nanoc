--- 
title: 4. Квантификация
---

<h1>4. Квантификация</h1>

<div class="slogan">
<blockquote><p>Гармония мира проявляется Формой и
  Числом, и потому и сердце, и душа, и вся поэзия
  Натуральной Философии воплощаются в понятиях
  математической красоты.</p><cite>
  Д'Арки Уентуорф Томпсон
  &laquo;О росте и форме&raquo; (1917)</cite></blockquote>
  </div>
  
<p> Существует множество методов количественного
  анализа элементов интерфейса. Однако ясное
  руководство о том, как использовать эти методы,
  можно встретить редко. В этой главе будет дано
  простое описание и подробные примеры модели GOMS,
  разработанной Кардом, Мораном и Ньюэллом, а также
  критерий эффективности Раскина, закон Хика и закон
  Фитса.</p>
  
<a name="s4.1"></a>
<h2>4.1. Количественный анализ интерфейса</h2>

<div class="slogan">
<blockquote><p>Он все тыкал и тыкал пальцами в
  компьютер, а Мелроуз просто изумлялся тому, что
  машина, которая предназначена для избавления
  человека от всей мелкой, рутинной работы,
  выполняла такую простую задачу настолько долго,
  что Буб, наверное, уже десять раз успел бы все
  сделать руками.</p><cite>
  Марта Граймс &laquo;The Stargazey&raquo;
  (детективный роман)</cite></blockquote>
  </div>
  
<p> Многие количественные и эвристические методы
  используются для анализа и изучения интерфейсов.
  Эти методы составляют значительную часть
  содержания большинства книг, посвященных этой
  теме, включая и те, которые указаны в
  библиографическом списке за такими авторами, как
  Шнейдерман (Shneiderman), Норман (Norman) и Мэйхью
  (Mayhew). Например, с помощью пассивного
  наблюдения за тестированием нового интерфейса с
  участием нескольких добровольцев<a name="p98"></a> опытный разработчик интерфейсов может узнать
  столько же ценной информации, сколько можно
  получить с помощью любого метода количественного
  анализа. Здесь я хочу сосредоточиться на
  количественных методах не для того, чтобы
  принизить значение качественных методов, но скорее
  для того, чтобы найти между ними баланс и показать
  ценность численных и эмпирических методов, которые
  не являются широко известными. Количественные
  методы часто могут свести спорные вопросы к
  простым вычислениям. Еще одним, более важным
  преимуществом этих методов является то, что они <i>помогают нам понять важнейшие аспекты
  взаимодействия человека с машиной</i>.</p>
  
<p> Одним из лучших подходов к количественному анализу
  моделей интерфейсов является классическая модель
  GOMS&nbsp;&mdash; &laquo;правила для целей, объектов, методов и
  выделения&raquo; (the model of goals, objects, methods,
  and selection rules), которая впервые привлекла к
  себе внимание в 80-х годах (Card, Moran and
  Newell, 1983). Моделирование GOMS позволяет
  предсказать, сколько времени потребуется опытному
  пользователю на выполнение конкретной операции при
  использовании данной модели интерфейса. После
  обсуждения модели GOMS мы рассмотрим
  количественные методы оценки производительности
  интерфейсов, скорости движения курсора и времени,
  необходимого для принятия решения.</p>
  
<h2>4.2. Модель скорости печати GOMS</h2>

<div class="slogan">
<blockquote><p>Цель точной науки заключается в
  том, чтобы свести проблемы природы к установлению
  количеств посредством операций с
  числами.</p><cite>
  Джеймс Клерк Максвелл &laquo;К вопросу о
  фарадеевых силовых линиях&raquo;
  (1856)</cite></blockquote></div>
  
<p> Здесь я хочу обсудить только один простейший, но
  довольно ценный аспект метода GOMS&nbsp;&mdash; модель,
  основанная на оценке скорости печати.
  Разработчики, которые знакомы с методом GOMS,
  редко проводят детальный и формальный анализ
  модели интерфейса. Отчасти это происходит из-за
  того, что основы GOMS и других количественных
  методов известны им настолько, что они изначально
  руководствуются этими методами в процессе
  разработки. К формальному анализу, конечно,
  прибегают в случаях, когда необходимо выбрать один
  из двух вариантов разработки, когда даже небольшие
  различия в скорости могут давать большой
  экономический и психологический эффект. Иногда
  разработчики пользуются поражающими своей
  точностью расширенными моделями GOMS, как,
  например, анализ с использованием метода
  критического пути GOMS (critical-path method GOMS,
  CPM-GOMS) или версия, называемая естественным
  языком GOMS (natural GOMS language, NGOMSL), в
  которой учитывается поведение неопытного
  пользователя, например время, необходимое ему для
  обучения. С помощью этих методов можно, например,
  предсказать, сколько времени понадобится
  пользователю для выполнения некоторого набора
  действий<a name="p99"></a> при использовании данного интерфейса с
  абсолютной погрешностью менее 5%. В расширенных
  моделях почти все оценки не выходят за пределы
  стандартного отклонения, принятого для измеренных
  значений времени (Gray, John и Atwood, 1993,
  с.&nbsp;278). Для вопросов, которые вызывают жаркие
  споры и по поводу которых авторитетные
  разработчики зачастую высказывают совершенно
  разные мнения, полезно вооружиться количественными
  методами, имеющими теоретическое обоснование и
  получившими экспериментальную апробацию. Более
  полный обзор и библиографию, посвященные различным
  моделям GOMS, можно найти у Джона (John, 1995);
  там же можно найти и модель CPM-GOMS,
  разработанную самим Джоном.</p>
  
<h3>4.2.1. Временные интервалы в интерфейсе</h3>

<div class="slogan">
<blockquote><p>Точность цифр есть истинная душа
  науки.</p><cite>
  Д'Арки Уентуорф Томпсон &laquo;О росте и
  форме&raquo; (1917)</cite></blockquote>
  </div>
  
<p> Разработчики модели GOMS во время ее создания
  заметили, что время, требующееся для выполнения
  какой-то задачи системой &laquo;пользователь&nbsp;&mdash;
  компьютер&raquo;, является суммой всех временных
  интервалов, которые потребовались системе на
  выполнение последовательности элементарных жестов,
  составляющих данную задачу. Хотя для разных
  пользователей время выполнения того или иного
  жеста может сильно отличаться, исследователи
  обнаружили, что для большей части <i>сравнительного</i> анализа задач, включающих
  использование клавиатуры и графического устройства
  ввода, вместо проведения измерений для каждого
  отдельного пользователя можно применить набор
  стандартных интервалов. С помощью тщательных
  лабораторных исследований был получен набор
  временных интервалов, требуемых для выполнения
  различных жестов. Ниже приводится оригинальная
  номенклатура, в которой каждый интервал обозначен
  одной буквой (Card, Moran и Newell, 1983).</p>
  
<table border=1 cellspacing=0 cellpadding=2>
  <tr>
	<td width="13%"><var>K = 0.2&nbsp;с</var></td>
	<td><p> Нажатие клавиши. 
		Время,
		необходимое для того, чтобы нажать клавишу.</p></td>
  </tr>
  <tr>
	<td><var>P = 1.1&nbsp;с</var></td>
	<td><p> Указание. Время, необходимое
		пользователю для того, чтобы указать на какую-то
		позицию на экране монитора.</p></td>
  </tr>
  <tr>
	<td><var>H = 0.4&nbsp;с</var></td>
	<td><p> Перемещение. Время, необходимое
		пользователю для того, чтобы переместить руку с
		клавиатуры на ГУВ или с ГУВ на клавиатуру.</p></td>
  </tr>
  <tr>
	<td><var>M = 1.35&nbsp;с</var></td>
	<td><p> Ментальная подготовка. Время,
		необходимое пользователю для того, чтобы умственно
		подготовиться к следующему шагу.</p></td>
  </tr>
  <tr>
	<td><var>R</var></td>
	<td><p> Ответ. Время, в течение которого
		пользователь должен ожидать ответ компьютера.</p></td>
  </tr>
</table>

<p> <a name="p100"></a> На практике указанные значения могут варьироваться
  в широких пределах. Для опытного пользователя,
  способного печатать со скоростью 135 слов/мин.,
  значение <var>K</var> может составлять 0.08&nbsp;с, для
  обычного пользователя, имеющего скорость 55
  слов/мин.,&nbsp;&mdash; 0.2&nbsp;с, для среднего неопытного
  пользователя, имеющего скорость 40 слов/мин.,&nbsp;&mdash;
  0.28&nbsp;с, а для начинающего&nbsp;&mdash; 1.2&nbsp;с. Нельзя
  сказать, что скорость набора не зависит от того,
  что именно набирается. Для того чтобы набрать одну
  букву из группы случайно взятых букв, большинству
  людей требуется около 0.5&nbsp;с. Если же это какой-то
  запутанный код (например, адрес электронной
  почты), то у большинства людей скорость набора
  составит около 0.75 символов в секунду. Значение <var>K</var> включает в себя и то время, которое
  необходимо пользователю для исправления сразу
  замеченных ошибок. Клавиша <kbd>&lt;Shift&gt;</kbd> считается за отдельное
  нажатие.</p>
  
<p> Широкая изменяемость каждой из представленных мер
  объясняет, почему эта упрощенная модель не может
  использоваться для получения абсолютных временных
  значений с какой-либо степенью точности. Тем не
  менее, с помощью типичных значений мы можем
  сделать правильную <i>сравнительную оценку</i> между какими-то двумя интерфейсами по уровню
  эффективности их использования. Если оцениваются
  сложные интерфейсы, включающие пересекающиеся
  временные зависимости, или если должны быть с
  точностью достигнуты определенные временные
  интервалы, то следует применять более сложные
  модели (например, CPM-GOMS), которые не
  рассматриваются в этой книге.</p>

<blockquote>
  <p> <b>Двойная &laquo;дискликсия&raquo;<a name="r20" href="#f20"><sup>20</sup></a></b></p>
  <p> Интерфейсная техника, называемая &laquo;двойным
	кликом&raquo;, т.е. двойное нажатие кнопки ГУВ за
	короткий временной промежуток и без какого-либо
	значительного перемещения курсора между двумя
	нажатиями, имеет некоторые недостатки. Вы не
	можете точно сказать, какие объекты на экране
	ответят на двойной клик, а какие нет. Кроме того,
	не всегда ясно, какой именно может быть ответ.
	Отображаемые на экране монитора элементы не имеют
	каких-либо признаков, означающих, что двойной клик
	может вызвать какой-то результат,&nbsp;&mdash; т.е. эта
	функциональность является невидимой. То, каким
	образом двойной клик используется во многих
	сегодняшних интерфейсах, вынуждает пользователей
	запоминать не только то, по <i>каким именно</i> элементам можно дважды щелкать мышью, но и то,
	какой результат возникает в ответ на этой действие
	по отношению к разным классам элементов
	интерфейса.</p>
	
  <p> Первые две проблемы можно, по крайней мере,
	частично решить с помощью использования новых
	условностей. Что касается двойного<a name="p101"></a> клика, то он сам по себе представляет проблему.
	Двойной клик требует использования кнопки мыши
	дважды в одном и том же месте или при небольшом
	перемещении и, в большинстве случаев, в течение
	небольшого промежутка времени, приблизительно за
	500 мс. Если пользователь щелкает слишком
	медленно, машина воспринимает это как два
	отдельных клика, а не как один двойной клик. Если
	пользователь слишком сильно двигает мышью в
	промежутке между двумя кликами, может произойти та
	же самая ошибка. Если пользователь слишком быстро
	нажимает кнопку ГУВ, например, как при работе с
	некоторыми текстовыми процессорами при попытке
	выделить буквы внутри слова, система может
	воспринять два нажатия как двойной клик и в
	результате будет выделено все слово.
  <p> Другая проблема возникает, когда пользователь
	пытается выделить графический элемент, который
	можно переместить с помощью ГУВ. Поскольку при
	быстром нажатии на кнопку ГУВ это устройство очень
	легко сдвинуть с места, графические программы
	могут воспринять это действие не как двойной клик,
	а как попытку переноса объекта в другое место
	(drag-and-drop). Аналогичным образом, чтобы
	изменить текст в окне, пользователь может
	посчитать необходимым изменить местоположение
	случайно сдвинутого окна и внести в текст
	поправки, которые изначально предполагались.
  <p> Некоторые из нас не страдают от дискликсии. Эти
	счастливые люди никогда не промахиваются мышью.
	Они могут вполне беззаботно и с особым
	своеобразием делать и один, и два клика по мыши и
	никоим образом не страдать от каких-то побочных
	эффектов. Они всегда помнят, что может система
	ответить на двойной щелчок, а что не может. Такие
	люди способны попасть из револьвера калибра 0,357
	в летящую птицу, двигаясь при этом на автомобиле
	по извилистой горной дороге. Однако нельзя
	рассчитывать на то, что все пользователи настолько
	удачливы. Поэтому интерфейс необходимо
	разрабатывать с учетом пользователей, страдающих
	от дискликсии, а также с учетом проблем, присущих
	использованию двойного клика.<a name="r21" href="#f21"><sup>21</sup></a></p>
	
</blockquote>
<p> Длительность ответа, поступающего от компьютера, <var>R</var>, может оказывать неожиданный эффект на
  действия пользователя. Если при использовании
  какого-то управляющего элемента на экране монитора
  в течение приблизительно 250&nbsp;мс ничего не
  возникает, пользователь, скорее всего, может
  почувствовать беспокойство, решит сделать еще одну
  попытку или подумает, что система неисправна.
<p> Нельзя сделать такой продукт, который мог бы
  завершать все операции за время, не превышающее
  времени реакции пользователя, но
  можно<a name="p102"></a> сделать такие интерфейсы, в которых в
  течение этого времени всегда бы выдавалось
  сообщение о том, что информация от пользователя
  принята и правильно распознана. В противном случае
  действия пользователя во время задержки&nbsp;&mdash; чаще
  всего просто молотьба по клавиатуре с целью
  получить хоть какой-то ответ&nbsp;&mdash; могут привести к
  нежелательным реакциям со стороны системы, приводя
  тем самым к еще большей задержке или даже
  повреждению содержания. Например, при попытке
  скачать какой-нибудь файл с America Online с
  помощью броузера (например, Netscape) очень часто
  возникает большая задержка. При этом не появляется
  никакого признака, что действительно что-то
  происходит. Возникает только небольшое статическое
  сообщение о том, что компьютер ждет ответа, но оно
  находится далеко за пределами локуса внимания
  пользователя. Через несколько секунд неопытный
  пользователь начинает кликать по кнопкам на
  экране, что приводит к остановке загрузки
  файла&nbsp;&mdash; опять же без всякого сообщения об этом.</p>
  
<p> Если задержки неизбежны, важно, чтобы в интерфейсе
  была предусмотрена сообщающая о них обратная
  связь,&nbsp;&mdash; например, можно использовать индикатор
  хода выполнения задачи (status bar) (рис.&nbsp;4.1),
  отражающий время, оставшееся до конца операции.
  Если неизвестно, сколько именно времени займет
  операция, так и скажите об этом пользователю!
  Нельзя лгать пользователю или вводить его в
  заблуждение.</p>

  <div class="image">
  <center>
	<img
src="img_4-1.jpg"/><br>
	<caption>
	<i><b>Рис.&nbsp;4.1.</b> Индикатор хода выполнения задачи. Важно, чтобы
	отображение времени было линейным. Текстовое
	сообщение об оставшемся времени, если оно точное,
	также можно считать человекоориентированным
	решением в тех случаях, когда задержки
	неизбежны</i>
	</caption>
  </center></div>

<h3>4.2.2. Расчеты по модели GOMS</h3>

<p> Вычисления времени, необходимого на выполнение
  того или иного действия (например, &laquo;переместить
  руку с графического устройства ввода на клавиатуру
  и набрать букву&raquo;), с помощью модели GOMS
  начинаются с перечисления операций из списка
  жестов модели GOMS (см. раздел 4.2.1.), которые
  составляют это действие (в приведенном примере это <var>H K</var>). Перечисление движений (<var>K</var>, <var>P</var> и <var>H</var>)&nbsp;&mdash; это довольно простая часть модели
  GOMS. Более сложным, например, в модели скорости
  печати GOMS, является определение точек, в которых
  пользователь остановится, чтобы выполнить
  бессознательную ментальную операцию,&nbsp;&mdash; интервалы
  ментальной подготовки, которые обозначаются
  символом <var>M</var>. Основные правила (по Card,
  Moran и Newell, 1983,
  с.&nbsp;265),<a name="p103"></a> позволяющие определить, в какие моменты
  будут проходить ментальные операции, представлены
  в табл. 4.1. В разделе 4.2.3 мы рассмотрим, как
  эти правила применяются на практике.</p>
  
<table border=1 cellspacing=0 cellpadding=2>
  <caption>
  <i>Таблица 4.1. Расстановка ментальных операций</i>
  </caption>
  <tr>
	<td valign="top"> Правило 0<br/>
	  Начальная расстановка операторов <var>M</var></td>
	<td valign="top"> Операторы <var>M</var> следует устанавливать перед всеми
	  операторами <var>K</var> (нажатие клавиши), а также перед всеми операторами <var>P</var> (указание с помощью ГУВ), предназначенными для выбора команд; но перед операторами <var>P</var>, предназначенными для указания на аргументы этих команд, ставить
	  оператор <var>M</var> не следует. </td>
  </tr>
  <tr>
	<td valign="top"> Правило 1<br/>
	  Удаление ожидаемых операторов <var>M</var></td>
	<td valign="top"> Если оператор, следующий за оператором <var>M</var>,
	  является полностью ожидаемым с точки зрения оператора, предшествующего <var>M</var>,
	  то этот оператор <var>M</var> может быть удален. Например, если вы перемещаете
	  ГУВ с намерением нажать его кнопку по достижении цели движения, то в соответствии
	  с этим правилом следует удалить оператор <var>M</var>, устанавливаемый по правилу
	  0. В этом случае последовательность <var>P M K</var> превращается в <var>P K</var>. </td>
  </tr>
  <tr>
	<td valign="top"> Правило 2<br/>
	  Удаление операторов <var>M</var> внутри когнитивных
	  единиц </td>
	<td valign="top"> Если строка вида <var>M K M K M K...</var> принадлежит
	  когнитивной единице, то следует удалить все операторы <var>M</var>, кроме
	  первого. Когнитивной единицей является непрерывная последовательность
	  вводимых символов, которые могут образовывать название команды или аргумент.
	  Например <i>Y</i>, <i>перемещать</i>, <i>Елена Троянская</i> или <i>4564.23</i> являются
	  примерами когнитивных единиц. </td>
  </tr>
  <tr>
	<td valign="top"> Правило 3<br/>
	  Удаление операторов <var>M</var> перед последовательными
	  разделителями </td>
	<td valign="top"> Если оператор <var>K</var> означает лишний разделитель,
	  стоящий в конце когнитивной единицы (например, разделитель команды,
	  следующий сразу за разделителем аргумента этой команды), то следует удалить
	  оператор <var>M</var>, стоящий перед ним. </td>
  </tr>
  <tr>
	<td valign="top"> Правило 4<br/>
	  Удаление операторов <var>M</var>, которые являются
	  прерывателями команд </td>
	<td valign="top"> Если оператор <var>K</var> является разделителем, стоящим
	  после постоянной строки (например, название команды или любая
	  последовательность символов, которая каждый раз вводится в неизменном виде),
	  то следует удалить оператор <var>M</var>, стоящий перед ним. (Добавление разделителя
	  станет привычным действием, и поэтому разделитель станет частью строки и не
	  будет требовать специального оператора <var>M</var>.) Но если оператор <var>K</var> является разделителем для строки аргументов или любой другой изменяемой
	  строки, то оператор <var>M</var> следует сохранить перед ним. </td>
  </tr>
  <tr>
	<td valign="top">Правило 5<br/>
	  Удаление перекрывающих операторов <var>M</var></td>
	<td valign="top">Любую часть оператора <var>M</var>, которая перекрывает 
	  оператор <var>R</var>, означающий задержку, связанную с ожиданием ответа 
	  компьютера, учитывать не следует. </td>
  </tr>
</table>

<p> <a name="p104"></a> Кроме того, отметим, что в этих правилах под
  строкой будет пониматься некоторая
  последовательность символов. <b>Разделителем</b> будет
  считаться символ, которым обозначено начало или
  конец значимого фрагмента текста, такого как,
  например, слово естественного языка или телефонный
  номер. Например, пробелы являются разделителями
  для большинства слов. Точка является наиболее
  распространенным разделителем, который
  используется в конце предложений. Скобки
  используются для ограничения пояснений и замечаний
  и т.д. Операторами являются <var>K</var>, <var>P</var> и <var>H</var>. Если для выполнения команды требуется
  дополнительная информация (как, например, в случае
  когда для установки будильника пользователю
  требуется указать время его включения), эта
  информация называется аргументом данной команды.</p>
  
<h3>4.2.3. Примеры расчетов по модели GOMS</h3>

<p> Разработка интерфейса обычно начинается с
  определения задачи или набора задач, для которых
  продукт предназначен. Суть задачи, а также
  средства, имеющиеся для реализации ее решения,
  часто формулируют в виде требования или
  спецификации. В нижеприведенном примере в качестве
  пользователя выступает лаборант Хол.</p>
<blockquote>
  <p> <b>Требования</b></p>
  <p> Хол работает на компьютере&nbsp;&mdash; печатает отчеты.
	Иногда его отвлекают экспериментаторы, находящиеся
	в этой же комнате, чтобы попросить перевести
	температурные показания из шкалы Фаренгейта в
	шкалу Цельсия или наоборот. Например, Холу могут
	сказать: &laquo;Переведи, пожалуйста, 302.25 градуса по
	шкале Фаренгейта в градусы по шкале Цельсия&raquo;.
	Значение температуры Хол может ввести только с
	помощью клавиатуры или ГУВ. Голосовые или другие
	средства ввода отсутствуют. Просьбы о переводе из
	одной шкалы в другую поступают приблизительно с
	равной вероятностью. Приблизительно 25%
	значений&nbsp;&mdash; отрицательные. 10% значений являются
	целочисленными (например, 37&deg;). Результат перевода
	из одной шкалы в другую должен отражаться на
	экране монитора. Другие средства вывода
	результатов не используются. Хол читает вслух
	экспериментатору полученное значение. Вводимые и
	выводимые числовые значения температур могут иметь
	до десяти цифр с каждой стороны от десятичного
	разделителя.</p>
	
  <p> При разработке интерфейса для системы, с помощью
	которой Хол сможет выполнять такие просьбы,
	следует минимизировать время, необходимое для
	перевода из одной шкалы в другую. Скорость и
	точность операций должны быть максимальными.
	Рабочая площадь экрана не ограничена. Окно или
	область экрана, предназначенная для перевода
	температурных значений, является постоянно
	активным и готово к вводу данных с помощью
	клавиатуры или ГУВ. То, каким образом Хол сможет
	вернуться к выполнению его
	основной<a name="p105"></a> работы, не учитывается. Задача считается
	выполненной с получением результата перевода.</p>
	
  <p> Для оценки требуемого Холу времени исходите из
	среднего временного значения на введение четырех
	символов, включая десятичную запятую. Также, из
	соображений простоты, будем считать, что Хол
	вводит все символы без ошибок, и поэтому средства
	выявления ошибок и сообщения о них не требуются.</p> 
	</blockquote>
	
<p> Сейчас я предлагаю читателям прервать чтение и
  попытаться разработать интерфейс по этим простым
  условиям. Для записи решения включая зарисовки
  изображений, которые будет наблюдать Хол на экране
  монитора, не потребуется много времени; поэтому
  постарайтесь не просто подумать об этой задаче, но
  и записать ее решение. (Возможно, вы захотите
  продолжить чтение, проигнорировав мою просьбу,
  однако я все же прошу вас подумать. Чтение
  последующих разделов будет намного более
  интересным, если вы сделаете попытку решить
  предложенную задачу самостоятельно.) После того
  как вы закончите разработку интерфейса,
  ознакомьтесь с анализами, проведенными по методу
  GOMS, которые будут представлены далее. После
  этого вы сможете проанализировать свой собственный
  вариант.</p>
  
<h4>4.2.3.1. Интерфейс для Хола: вариант 1.
  Диалоговое окно</h4>
  
<p> Инструкции в диалоговом окне (рис.&nbsp;4.2) довольно
  просты. На их основе можно описать метод действий,
  который должен использовать Хол в терминах жестов
  модели GOMS. Запись по модели GOMS будет
  представлена последовательно по мере того, как
  будут добавляться новые жесты.</p>

  <div class="image">
  <center>
	<img
src="img_4-2.jpg"/><br>
	<caption>
	<i><b>Рис.&nbsp;4.2.</b> Вариант диалогового окна с использованием группы
	переключателей</i>
	</caption>
  </center>
  </div>
  
<ul>
  <li>Перемещение руки к графическому устройству
	ввода данных:
	<p> <var>H</var></p>
  <li>Перемещение курсора к необходимому
	переключателю в группе:
	<p> <var>H P</var></p>
  <li>Нажатие на необходимый переключатель:
	<p> <var>H P K</var></p>
</ul>
<p> <a name="p106"></a> В половине случаев в интерфейсе уже будет выбрано
  требуемое направление перевода, и поэтому Холу не
  придется кликать на переключатель. Сейчас мы
  рассматриваем случай, когда переключатель не
  установлен в требуемое положение.</p>
<ul>
  <li>Перемещение рук снова к клавиатуре:
	<p> <var>H P K H</var></p>
  <li>Ввод четырех символов:
	<p> <var>H P K H K K K K</var></p>
  <li>Нажатие клавиши <kbd>&lt;Enter&gt;</kbd>:
	<p> <var>H P K H K K K K K</var></p>
</ul>
<p> Нажатие клавиши <kbd>&lt;Enter&gt;</kbd> завершает
  часть анализа, касающуюся метода. В соответствии с
  правилом 0 мы ставим оператор <var>M</var> перед всеми
  операторами <var>K</var> и <var>P</var> за исключением
  операторов <var>P</var>, указывающих на аргументы,
  которых в нижеследующем примере нет:</p>
<p> <var>H M P M K H M K M K M K M K M K</var></p>
<p> Правило 1 предписывает заменить <var>P M K</var> на <var>P K</var> и удалить все другие операторы <var>M</var>, которые являются ожидаемыми (в указанном
  примере таких нет). Кроме того, правило 2
  предписывает удалять операторы <var>M</var> в середине
  цепочек. После применения этих двух правил
  остается следующая запись:</p>
  
<p> <var>H M P K H M K K K K M K</var></p>
<p> В соответствии с правилом 4 следует оставить
  оператор <var>M</var> перед конечным <var>K</var>. Правила
  3 и 5 в данном примере не применяются.</p>
<p> Следующий шаг&nbsp;&mdash; это заменить символы операторов
  на соответствующие временные интервалы (напомним,
  что <var>K=0.2</var>; <var>P=1.1</var>; <var>H=0.4</var>; <var>M=1.35</var>).</p>
<p> <var>H + M + P + K + H + M + K + K + K + K + M + K = 0.4 + 1.35 + 1.1 + 0.2 + 0.4 + 1.35 + 4*(0.2) + 1.35 + 0.2 = 7.15&nbsp;с</var></p>
<p> В случае когда переключатель уже установлен в
  требуемое положение, метод действий становится
  следующим:</p>
<p> <var>M K K K K M K</var></p>
<p> <var>M + K + K + K + K + M + K = 3.7&nbsp;с</var></p>
<p> По условиям задачи оба случая являются
  равновероятными. Таким образом, среднее время,
  которое потребуется Холу на использование
  интерфейса для перевода из одной шкалы в другую,
  составит (7.15+3.7)/2 &asymp; 5.4&nbsp;с.  Но
  поскольку описанные два метода являются разными,
  Холу будет трудно использовать их автоматично.
  Нерешенной проблемой количественных методов
  анализа остается оценка процента появления ошибок
  при использовании данной модели интерфейса.</p>
  
<p> <a name="p107"></a> Далее мы рассмотрим графический интерфейс, в
  котором используется известная всем метафора.</p>
  
<h4>4.2.3.3. Интерфейс для Хола: вариант 2. ГИП
  (GUI, graphical user interface)</h4>

  <div class="image">
  <center>
	<img
src="img_4-3.jpg" alt=""/><br>
	<caption>
	<i><b>Рис.&nbsp;4.3.</b> ГИП
	для задачи Хола</i>
	</caption>
  </center>
  </div>
  
<p> В интерфейсе, показанном на рис.&nbsp;4.3, используется
  наглядное отображение термометров. Хол может
  поднять или опустить указатель на каждом
  термометре методом перетаскивания с помощью ГУВ.
  Хол определяет, какой ему необходимо сделать
  пересчет, перемещая стрелку указателя либо по
  шкале Цельсия, либо по шкале Фаренгейта. Холу не
  требуется вводить символы посредством
  клавиатуры&nbsp;&mdash; он просто выбирает значение
  температуры на одном из термометров. При
  перемещении указателя на одном термометре
  указатель на другом перемещается на
  соответствующее значение. Точность устанавливается
  с помощью регуляторов масштабирования шкал. Также
  возможно изменить текущий диапазон значений.
  Изменение шкалы или диапазона
  на<a name="p108"></a> одном термометре автоматически приводит к
  соответствующему изменению на другом. Точное
  числовое значение отображается на перемещаемой
  стрелке. Температура показывается как в числовом
  виде так и с помощью уровня градусника, поэтому
  Хол может, на свое усмотрение, пользоваться либо
  графическим вариантом представления данных, либо
  символьным. Сервис &laquo;Автомед&raquo; позволяет
  установить диапазоны термометров с центром в
  районе 37 градусов шкалы Цельсия и 98.6 градусов
  Фаренгейта на случай, если кто-то из сотрудников
  работает со значениями температуры тела человека.
  Эта опция служит для экономии времени.</p>
  
<p> С помощью нажатия кнопок &laquo;Расширить шкалу&raquo;
  (Expand Scales) и &laquo;Сжать шкалу&raquo; (Compress
  Scales) можно уменьшить или увеличить цену деления
  шкал в 10 раз. Для перехода к значению, которое в
  данный момент не видно на экране, Хол расширяет
  шкалу, затем прокручивает до нужного места на
  шкале, устанавливает стрелку на необходимое
  температурное значение и потом сжимает шкалу до
  получения требуемой точности, при необходимости
  подстраивая стрелку указателя.</p>
  
<p> Провести анализ этого графического интерфейса с
  помощью модели скорости печати GOMS довольно
  сложно, поскольку способ, которым Хол может его
  использовать, зависит от того, где в данный момент
  установлена стрелка указателя, какой необходим
  диапазон температур и какая требуется точность.
  Рассмотрим сначала простой случай, при котором
  диапазон температурных шкал и точность перевода
  уже находятся в желаемом положении. Анализ
  позволит определить минимальное время, необходимое
  для использования этого интерфейса.</p>
  
<ul>
  <li>Запишем, какие жесты использует Хол, когда
	перемещает руку к ГУВ, щелкает по кнопке и
	удерживает ее, указывая на стрелку одного из
	термометров:
	<p> <var>H P K</var></p>
  <li>Продолжим записывать те жесты, которые
	использует Хол для перемещения стрелки к
	необходимому температурному значению и отпускает
	кнопку ГУВ
	<p> <var>H P K P K</var></p>
  <li>Поставим операторы <var>M</var> в соответствии с
	правилом 0:
	<p> <var>H M P M K M K</var></p>
  <li>Удалим два оператора <var>M</var> в соответствии с
	правилом 1:
	<p> <var>H M P K K</var></p>
</ul>
<p> Когнитивные единицы, разделители
  последовательностей и т.д. здесь не используются,
  поэтому правила 2-5 не применяем. Складывая
  значения операторов, получаем общее время:</p>
<p> <var>H M P K K</var></p>
<p> <var>0.4 + 1.35 + 1.1 + 0.2 + 0.2 = 3.25&nbsp;с</var></p>
<p> <a name="p109"></a> Результат вычисления относится к удачному случаю,
  когда исходный термометр уже предустановлен на
  требуемый диапазон и точность. Теперь рассмотрим
  случай, при котором Хол расширяет шкалу, чтобы
  увидеть необходимое температурное значение,
  изменяет диапазон, сжимает шкалу, чтобы получить
  требуемую точность, и затем перемещает стрелку
  указателя. Далее я привожу общую запись метода,
  который использует Хол, без промежуточных шагов.
  (Я исхожу из того, что Хол является опытным
  пользователям и не прокручивает шкалу туда и
  обратно, чтобы найти на ней нужный участок.) Холу
  приходится несколько раз пользоваться стрелками
  для прокрутки температурной шкалы. На каждую
  операцию прокручивания экрана может потребовать
  нескольких жестов. Кроме того, требуется время на
  то, чтобы отобразить изменения на экране,
  связанные с его прокруткой. Чтобы оценить время
  прокручивания, я построил такой интерфейс и
  измерил эти значения. Все они были равны 3&nbsp;с и
  более. Обозначая время прокручивания шкал через <var>S</var>, запишем последовательность жестов,
  которые применяет Хол.</p>
  
<p> <var>H P K S K P K S K P K S K P K K</var></p>
<p> В соответствии с правилами расставляем операторы <var>M</var>:</p>
<p> <var>H + 3(M  + P + K + S + K) + M + P + K + K</var></p>
<p> <var>0.4 + 3*(1.35  + 0.2 + 3.0 +  0.2) + 1.35 + 0.4 + 0.2 + 0.2 = 16.8&nbsp;с</var></p>
<p> За исключением редких случаев, когда шкалы уже с
  самого начала установлены правильно, идеальному
  пользователю понадобится более 16&nbsp;с на то, чтобы
  выполнить перевод из одной шкалы в другую, тогда
  как реальный, т.е. не идеальный пользователь,
  может сбивать шкалы и стрелки указателей, и
  поэтому ему понадобится даже больше времени.</p>
  
<h2>4.3. Измерение эффективности интерфейса</h2>

<div class="slogan">
<blockquote><p>Каждый инструмент несет с собой тот
  дух, в котором он был создан.</p><cite>
  Вернер Карл
  Гейзенберг</cite></blockquote></div>
  
<p> Мы рассмотрели два интерфейса: в одном из которых
  требуется около 5&nbsp;с на выполнение задачи, а в
  другом&nbsp;&mdash; более 15&nbsp;с. Отсюда ясно, какой из
  интерфейсов лучше удовлетворяет поставленным
  условиям. Следующий вопрос&nbsp;&mdash; это определить,
  насколько быстро работает тот интерфейс, который
  отвечает поставленным требованиям.</p>
  
<p> Если имеется модель интерфейса, то с помощью GOMS
  и его расширений можно определить время,
  необходимое пользователю на выполнение любой,
  четко сформулированной задачи, для которой данный
  интерфейс предусмотрен. Однако модели анализа не
  могут дать ответ на вопрос о том, насколько быстро
  должен работать интерфейс. Чтобы ответить на него,
  мы можем воспользоваться мерой, применяемой в
  теории информации. Далее мы будем рассматривать
  термин <i>информация</i><a name="p110"></a> в техническом смысле, т.е. как
  квантификацию некоторого объема данных,
  передаваемых с помощью средства коммуникации, как,
  например, при разговоре двух людей по телефону,
  или если человек подает некоторый сигнал машине,
  например с помощью нажатия кнопки ГУВ, когда
  курсор находится в определенной области экрана.
  Перед тем как углубиться в детали техники
  измерения того, какой объем информации нужен для
  выполнения поставленной задачи, обоснуем
  необходимость такого измерения.</p>
  
<p> Чтобы сделать правильную оценку времени,
  необходимого на выполнение задачи с помощью самого
  быстрого интерфейса, прежде всего следует
  определить минимальное количество информации,
  которое пользователь должен ввести, чтобы
  выполнить задачу. Это минимальное количество не
  зависит от модели интерфейса. Если методы работы,
  используемые в предполагаемом интерфейсе, требуют
  введения такого количества информации, которое
  превышает минимальное, это означает, что
  пользователь делает лишнюю работу, и поэтому
  интерфейс можно усовершенствовать. С другой
  стороны, если от пользователя требуется ввести
  именно то количество информации, которое
  необходимо для выполнения задачи, то для этой
  задачи интерфейс нельзя сделать более
  производительным путем изменения количества
  информации. В этом случае пути улучшения
  интерфейса (а также много путей для ухудшения) все
  же остаются, но по крайней мере данная цель
  повышения производительности будет уже достигнута.</p>
  
<p> <b>Информационно-теоретическая
  производительность</b> определяется так же, как
  понятие производительности определяется в
  термодинамике&nbsp;&mdash; отношением мощности на выходе к
  мощности на входе процесса. Если в течение
  какого-то периода времени электрогенератор,
  работающий от двигателя производительностью в 1000
  ватт, производит 820 ватт, то он имеет
  производительность 820/100=0.82.
  Производительность также часто обозначается через
  проценты. В этом случае производительность
  электрогенератора будет составлять 82%. Идеальный
  генератор (который не может существовать с точки
  зрения второго закона термодинамики) должен иметь
  производительность 100%.</p>
  
<p> <b>Информационная производительность</b> интерфейса <var>E</var> определяется как отношение
  минимального количества информации, необходимого
  для выполнения задачи, к количеству информации,
  которое должен ввести пользователь. Так же как и в
  отношении физической производительности, параметр <var>E</var> может изменяться в пределах от 0 до 1.
  Если никакой работы для выполнения задачи не
  требуется или работа просто не производится, то
  производительность составляет 1. (Это формальное
  положение вводится для того, чтобы избежать
  деления на 0, как в случае ответа на выводимое
  прозрачное сообщение об ошибке (см. раздел 5.5).)
<p> Производительность <var>E</var> может равняться и 0 в
  случаях, когда пользователь должен ввести
  информацию, которая совершенно бесполезна
  (рис.&nbsp;4.4). Следует отметить, что в интерфейсах
  можно встретить немало<a name="p111"></a> деталей, которые имеют сомнительную ценность
  из-за параметра <var>E=0</var>. Примером такого
  бесполезного элемента может быть диалоговое окно,
  в котором есть только одна-единственная
  возможность для действия пользователя, например
  кнопка OK. (В JavaScript есть даже специальная
  команда <kbd>Alert</kbd>, предназначенная только для того,
  чтобы делать такие ненужные диалоговые окна.
  Разработчики языка JavaScript были достаточно
  разумны, чтобы убрать из него команду <kbd>goto</kbd> и
  сделать программирование на этом языке
  структурным, но они упустили из виду аспект
  интерфейса.)</p>
  
<div class="image">
  <center>
	<img
src="img_4-4.jpg" alt=""/><br>
	<caption>
	<i><b>Рис.&nbsp;4.4.</b> Диалоговое окно с информационной теоретической
	эффективностью 0</i>
	</caption>
  </center></div>
  
<p> В параметре <var>E</var> учитывается только
  информация, необходимая для задачи, и информация,
  вводимая пользователем. Два или более методов
  действия могут иметь одинаковую производительность <var>E</var>, но иметь разное время выполнения.
  Возможно даже, что один метод имеет более высокий
  показатель <var>E</var>, но действует медленнее, чем
  другой метод,&nbsp;&mdash; например <var>M K M K</var> и <var>M K K K</var>. 
  В этом примере при использовании первого
  метода должно быть введено только два символа. При
  использовании второго метода требуется ввести три
  символа, но времени на все действие тратится
  меньше. Трудно привести другие примеры из обычной
  жизни, в которых происходит аналогичная
  перестановка скорости и информационной
  производительности.<a name="r22" href="#f22"><sup>22</sup></a> Как правило, чем более
  производительным является интерфейс, тем более
  продуктивным и более человекоориентированным он
  является.</p>
  
<p> Информация измеряется в битах. Один бит, который
  представляет собой один из двух альтернативных
  вариантов (таких как 0 или 1, да или нет),
  является единицей информации.<a name="r23" href="#f23"><sup>23</sup></a> Например, чтобы
  выбрать один из каких-либо четырех объектов,
  потребуется 2 бита информации. Если объекты
  обозначить как A, B, C и D, первый бит информации<a name="p112"></a> определит выбор между A и B или C и D. Когда
  первый выбор сделан (например, C и D), второй бит
  определит выбор между следующими двумя элементами
  (либо C, либо D). Двух двоичных выборов, или двух
  битов, достаточно для выбора одного элемента из
  четырех. Чтобы сделать выбор из группы восьми
  элементов, потребуется 3 бита. Из шестнадцати
  элементов&nbsp;&mdash; 4 бита, и т.д. В общем случае при
  количестве <var>n</var> равновероятных вариантов
  суммарное количество передаваемой информации
  определяется как степень 2, равная <var>n</var>:</p>
  
<p> <var>\log_2 n</var></p>

<p> Количество информации для каждого варианта
  определяется как</p>
<table border=0 width="100%">
  <tr>
	<td><var>(1/n) \log_2 n</var></td>
	<td align="right">(1)</td>
	</tr>
</table>
<p> Если вероятности для каждой альтернативы не
  являются равными и <var>i</var>-я альтернатива имеет
  вероятность <var>p(i)</var>, то информация,
  передаваемая этой альтернативой, определяется как</p>
<table border=0 width="100%">
  <tr>
	<td><var>p(i) \log_2(1/p(i))</var></td>
	<td align="right">(2)</td>
	</tr>
</table>
<p> Количество информации является суммой (по всем
  вариантам) выражения (2), которое при
  равновероятных вариантах сводится к выражению (1).
  Отсюда следует, что информационное содержание
  интерфейса, в котором возможно сделать только
  нажатие единственной клавиши (а ненажатие клавиши
  не допускается), составляет 0 бит:</p>
<table border=0 width="100%">
  <tr>
	<td><var>1 \log_2(1) = 0</var></td>
	<td align="right">(3)</td>
	</tr>
</table>
<p> Однако может показаться, что нажатие единственной
  клавиши способно, например, вызвать подрыв
  динамита для разрушения здания. Таким образом,
  передает ли это нажатие какую-нибудь информацию?
  На самом деле нет, потому что ненажатие кнопки не
  было предусмотрено как альтернатива&nbsp;&mdash; интерфейс
  допускает &laquo;только нажатие единственной клавиши&raquo;.
  Если же нажатие клавиши не производится в течение
  5-минутного периода, когда подрыв возможен, то
  здание не будет разрушено, и поэтому нажатие или
  ненажатие передает до 1 бита информации, так как в
  этом случае имеется альтернатива из двух
  вариантов. Из выражения (2) следует, что в
  вычислениях используется вероятность (<var>p</var>)
  того, что здание будет разрушено. Таким образом,
  вероятность того, что оно не будет разрушено,
  составляет <var>1-p</var>. С помощью выражения (2) мы
  можем вычислить информационное содержание данного
  интерфейса:</p>
<table border=0 width="100%">
  <tr>
	<td><var>p \log_2(1/p) + (1-p) \log_2(1/(1-p))</var></td>
	<td align="right">(4)</td>
	</tr>
</table>
<p> При <var>p=S</var> результат выражения (4) составит:</p>
<p> <var>S*1 + S*1 = S + S = 1</var></p>
<p> Значение выражения (4) будет меньше 1, если <var>p &ne; S</var>. В частности при <var>p = 0</var> или <var>p = 1</var> оно составит 0, как это видно из
  выражения (3).</p>
<p> <a name="p113"></a> Этот пример показывает важный момент, который
  заключается в том, что мы можем оценить объем
  информации, содержащейся в сообщении, только в
  контексте всего набора возможных сообщений. Чтобы
  подсчитать количество информации, передаваемой
  некоторым полученным сообщением, необходимо знать
  в частности вероятность, с которой это сообщение
  может быть отправлено. Количество информации в
  любом сообщении не зависит от других сообщений,
  которые были в прошлом или могут быть в будущем,
  не связано со временем или продолжительностью и не
  зависит от каких-либо иных событий, так же как
  результат подбрасывания симметричной монеты не
  зависит от результата предыдущих подбрасываний или
  от времени дня, когда это подбрасывание
  производится.</p>
<p> Кроме того, важно учитывать, что:</p>
<blockquote>
  <p> &laquo;нельзя путать понятие информации с понятием
	смысла ...информация является мерой свободы выбора
	сообщения... Следует отметить, что при наличии
	только двух возможных сообщений утверждать, что
	какое-то сообщение передает какой-то объем [1 бит]
	информации, неправильно. Понятие информации не
	применимо к отдельным сообщениям (в отличие от
	понятия смыла), но применимо к ситуации в целом;
	при этом единица информации показывает, что в
	данной ситуации имеется некоторый объем свободы в
	выборе сообщения, который удобно обозначать как
	стандартный или единичный объем информации&raquo;
	(Shannon и Weaver, 1963, с.&nbsp;9). </p>
</blockquote>

<p> Однако действия, которые совершает пользователь
  при выполнении задачи, можно с большей точностью
  смоделировать в виде процесса Маркова, в котором
  вероятность последующих действий зависит от уже
  совершенных пользователем действий. Тем не менее,
  для данного рассмотрения достаточно использовать
  упомянутые вероятности отдельных, единичных
  событий, при этом будем исходить из того, что все
  сообщения являются независимыми друг от друга и
  равновероятными.</p>
  
<p> Также можно вычислить количество информации,
  которое передается с помощью устройств,
  отличающихся от клавиатуры. Если экран дисплея
  разделен на две области&nbsp;&mdash; со словом &laquo;Да&raquo; в
  одной области и словом &laquo;Нет&raquo;&nbsp;&mdash; в другой, то
  один клик, совершенный в одной из областей, будет
  передавать 1 бит информации. Если имеется <var>n</var> равновероятных объектов, то нажатием на один из
  них сообщается <var>\log_2 n</var> бит информации.
  Если объекты имеют разные размеры, то количество
  информации, сообщаемой каждым из них, не
  изменяется, но увеличивается время перемещения ГУВ
  к более мелким объектам (далее мы покажем способ
  вычисления этого времени). Если объекты имеют
  разные вероятности, формула остается аналогичной
  той, которая была дана для случая ввода с
  клавиатуры разновероятных данных. Различие состоит
  только в том, что для нажатия клавиши может
  потребоваться 0.2&nbsp;с. тогда как для нажатия кнопки,
  изображенной на экране, в среднем может
  потребоваться около 1.3&nbsp;с (без учета времени
  перемещения руки пользователя с клавиатуры на
  ГУВ).</p>
  
<p> <a name="p114"></a> В случае голосового ввода информации его
  информационное содержание можно вычислить, если
  рассматривать речь как последовательность вводимых
  символов, а не как непрерывный поток определенного
  диапазона и продолжительности.</p>
  
<p> Данный подход к теории информации и ее связи с
  разработкой интерфейсов является упрощенным. Но
  даже в такой упрощенной форме, которую мы также
  использовали при рассмотрении модели GOMS, теория
  информации может дать нам общий критерий оценки
  качества интерфейса.</p>
  
<h3>4.3.1. Производительность интерфейса для
  Хола</h3>
 
 <div class="slogan">
<blockquote><p>Аккуратный подсчет есть путь к
  знаниям всех существующих вещей и тайных
  секретов.</p><cite>
  Папирусы Рхинда, 1650&nbsp;г. до н.
  э.</cite></blockquote></div>
  
<p> Полезно подробно рассмотреть пример вычисления
  среднего количества информации, требуемого для
  некоего интерфейса. Для этого я снова использую
  пример интерфейса для перевода температур из одной
  шкалы в другую. В соответствии с условиями
  требуется, чтобы количество символов, вводимых в
  температурный преобразователь, равнялось в среднем
  4. Кроме того, по условиям задачи десятичная точка
  используется однократно в 90% вводимых данных, а в
  10%&nbsp;&mdash; вообще не встречается; знак минус
  появляется один раз в 25% данных и совсем не
  встречается в остальных 75% данных. Из соображений
  простоты, а также потому, что не требуется ответ с
  точностью до 1%, я буду исходить из того, что все
  остальные цифры встречаются с одинаковой частотой,
  и не буду учитывать те 10% данных, которые не
  содержат десятичной точки.</p>
  
<p> Требуется определить множество возможных вариантов
  ввода и их вероятности. Возможны 5 вариантов
  (<var>d</var> означает цифру):</p>
<ol>
  <li> <var>-.dd</var></li>
  <li> <var>-d.d</var></li>
  <li> <var>.ddd</var></li>
  <li> <var>d.dd</var></li>
  <li> <var>dd.d</var></li>
</ol>
<p> Первые два варианта встречаются в 12.5% случаев, и
  количество каждого из них составляет 100. Каждый
  из последних трех вариантов встречается в 25%
  случаев, и количество каждого из них составляет
  почти 1000.<a name="r24" href="#f24"><sup>24</sup></a> Вероятность каждого из первых двух
  вариантов ввода составляет (0.125/100)=0.00125.
  Вероятность любого из последних
  трех<a name="p115"></a> вариантов ввода составляет
  (0.75/3000)=0.00025. Сумма вероятностей, как это и
  должно быть, составляет 1.</p>
  
<p> Количество информации (в битах), передаваемое
  каждым вариантом, определяется выражением (2)<a name="r25" href="#f25"><sup>25</sup></a>:</p>
<p> <var>p(i) \log_2(1/p(i))</var></p>
<p> Значение этого выражения составляет приблизительно
  0.012 для отрицательных значений ввода и 0.003&nbsp;&mdash;
  для положительных.
  200*0.00674+3000*0.003 дает в сумме 11.4
  бита для каждого варианта ввода.</p>
  
<p> Важно учесть вероятности вариантов. Если
  использовать простой подход, в котором все 12
  символов (минус, десятичная точка и 10 цифр)
  принять как равновероятные, то вероятность каждого
  символа составит 1/12, а количество информации,
  содержащейся в 4-значном варианте ввода, составит
  приблизительно</p>
  
<p> <var>4 \log_2(12) &asymp; 14 бит</var></p>
<p> В теории информации есть теорема, в которой
  утверждается, что максимум информации передается
  при условии, что все символы равновероятны.
  Поэтому если принять все варианты как
  равновероятные, то общее значение будет равно
  количеству информации в каждом отдельном варианте
  или превышать его. Очевидно, что такое допущение
  позволяет упростить вычисление информационного
  содержания. Если же результирующее значение
  приближенного вычисления меньше количества
  информации, которое пользователь должен ввести в
  интерфейс, то проводить еще более точные
  вычисления уже нет необходимости.</p>
  
<p> Мы только что выяснили, что каждый раз, когда Холу
  требуется провести преобразование температурных
  значений, он должен ввести в среднем около 11 бит
  информации. Мы можем разделить это количество на
  то количество информации, которое требуется ввести
  в интерфейс, что мы сейчас и сделаем. В результате
  мы получим производительность (эффективность)
  данного интерфейса.</p>
  
<p> Другим упрощением, позволяющим провести быстрый
  анализ интерфейса, является вычисление различных
  жестов на основе количества информации,
  передаваемого одним нажатием клавиши или одной
  операцией ГУВ. При передаче информации нажатием
  клавиши ее количество зависит от общего количества
  клавиш и относительной частоты использования
  каждой из них. Таким образом, нажатия клавиши
  могут использоваться как приблизительная мера
  информации. Если на клавиатуре имеется 128 клавиш,
  и каждая из них используется с одинаковой
  частотой, то нажатие любой из них будет передавать
  7 бит информации.<a name="p116"></a> В действительности частота использования
  клавиш субщественно различается. Например, пробел
  или буква <kbd>е</kbd> используются чаще, чем <kbd>й</kbd> или <kbd>\</kbd>, поэтому в большинстве приложений на каждое
  нажатие клавиши приходится в среднем около 5
  битов. По условиям нашей задачи среднее число
  символов вводимых температурных значений не должно
  превышать 4.</p>
  
<p> Для данного анализа удобнее использовать более
  простую меру, чем теоретическая информационная
  производительность. <b>Символьная
  эффективность</b> часто имеет такую же
  практическую ценность, что и информационная
  производительность. Она определяется как
  минимальное количество символов, необходимое для
  выполнения задачи, отнесенное к количеству
  символов, которое в данном интерфейсе требуется
  ввести пользователем.</p>
  
<p> Если в нашем интерфейсе потребуется вводить в
  среднем 4 символа, то символьная эффективность
  такого интерфейса составит 100%. При
  добавлении еще одной клавиши, обозначающей шкалу
  перевода температурного значения, а также еще
  одной для разделения, средняя длина ввода
  возрастет до 6 символов, а символьная
  эффективность снизится до 67%. Если в качестве
  устройства ввода Хол будет использовать числовую
  клавиатуру, состоящую из 16 клавиш, то каждой
  отдельной клавишей будет передаваться 4 бита
  информации, и поэтому производительность
  интерфейса возрастет. (Однако по условиям задачи
  такой возможности не предусмотрено.)</p>
  
<p> Поскольку любая задача в соответствии с анализом
  GOMS требует как минимум одного ментального
  оператора, наиболее производительный интерфейс с
  использованием клавиатуры для перевода
  температурных значений из одной шкалы в другую
  будет теоретически иметь следующее среднее время
  использования:</p>
<p> <var>M + K + K + K + K = 2.15&nbsp;с</var></p>
<p> Таким образом, он будет значительно быстрее, чем
  любой из двух уже рассмотренных вариантов. Однако
  введение 4 символов с помощью стандартной
  клавиатуры дает, по крайней мере, 20 бит
  информации, тогда как требуется только 10.
  Следовательно, теоретическая информационная
  производительность составляет 55%, а значит,
  существует возможность улучшения. Как мы уже
  видели, использование стандартной числовой
  клавиатуры вместо полной клавиатуры снижает объем
  информации, вводимой на каждые 4 символа, до 16
  бит, что повышает производительность до 60%.
  Желаемая числовая клавиатура, содержащая только
  цифры, знак минус и десятичную точку, позволит
  немного повысить производительность&nbsp;&mdash; до 70%.
  Дальнейшее повышение производительности возможно
  через использование особых кодировок обозначений
  температуры и изобретение новых устройств ввода,
  но здесь возникают трудности, связанные с
  обучением и лишними расходами, поэтому остановимся
  на варианте с 70% теоретической информационной
  производительности. Независимо от того, могут ли
  теоретические<a name="p117"></a> границы быть достигнуты на практике
  или нет, они дают нам направление в разработке
  интерфейса.</p>
  
<h3>4.3.2. Другие решения интерфейса для Хола</h3>
<p> В разделе 4.3.1 мы приостановили дальнейшие
  попытки улучшения интерфейса, достигнув 70%
  теоретической информационной производительности.
  Данная производительность определена для пока еще
  неизвестного, теоретического интерфейса, в котором
  каким-то образом можно получить 100% эффективность
  использования клавиш. Давайте посмотрим, насколько
  мы можем приблизиться к этому идеалу с помощью
  стандартной клавиатуры и ГУВ.</p>
<p> Рассмотрим интерфейс, в котором используется
  клавиатура со всеми символами. В таком интерфейсе
  на экране появляется следующее сообщение:</p>
<blockquote>
  <table border=1 cellspacing=1 cellpadding=8>
	<tr>
	  <td><p> Для перевода температуры из одной шкалы в другую
		  укажите нужную шкалу с помощью символа C (шкала
		  Цельсия) или F (шкала Фаренгейта). Введите
		  числовое значение температуры, затем нажмите
		  клавишу Enter. Результат преобразования будет
		  отображен на экране.</p> </td>
	</tr>
  </table>
</blockquote>
<p> GOMS-анализ показывает, что пользователь должен
  сделать 6 нажатий клавиш. По правилам расстановки
  операторов <var>M</var> получаем .следующую запись:</p>
<p> <var>M K K K K K M K</var></p>
<p> Среднее время составит 3.9&nbsp;с.</p>
<p> Мы можем уменьшить это время, если сами символы C
  и F будем использовать в качестве разделителей.
  Рассмотрим интерфейс, в котором появляется
  следующая инструкция:</p>
<blockquote>
  <table border=1 cellspacing=1 cellpadding=8>
	<tr>
	  <td><p> Для перевода температуры из одной шкалы в другую
		  введите числовое значение температуры и следом
		  поставьте символ C, если оно в шкале Цельсия, или
		  F, если оно в шкале Фаренгейта. Результат
		  преобразования будет отображен на экране. </p></td>
	</tr>
  </table>
</blockquote>
<p> В данном примере нажимать на клавишу <kbd>&lt;Enter&gt;</kbd> не требуется. Некоторые
  примитивные средства разработки интерфейсов
  требуют, чтобы пользователь обязательно
  использовал клавишу <kbd>&lt;Enter&gt;</kbd>, и
  поэтому в них невозможно использовать символы C и
  F в качестве разделителей. Такие инструменты не
  подходят для разработки человекоориентированных
  интерфейсов.</p>
<p> <a name="p118"></a> GOMS-анализ показывает, что для интерфейса с
  символами C и F в качестве разделителей запись
  будет следующей:</p>
<p> <var>M K K K K M K</var></p>
<p> Среднее время составит 3.7&nbsp;с. Если бы мы не знали,
  что теоретически минимальное время составляет 2.15
  с, то это решение могло бы показаться удачным. Оно
  является значительно более эффективным, чем ранее
  рассмотренные, поэтому мы могли бы на нем
  остановиться. Однако теоретический минимум
  подстегивает нас к поиску еще более быстрой
  интерфейсной модели. Рассмотрим интерфейс,
  изображенный на рис.&nbsp;4.5. Такой интерфейс можно
  назвать <i>разветвленным</i>. В нем один ввод дает
  в результате два вывода.</p>

  <div class="image">
  <center>
	<img
src="img_4-5.jpg"/><br>
	<caption>
	<i><b>Рис.&nbsp;4.5.</b> Интерфейс, в котором не используется разделитель.
	Более эффективным является вариант, в котором
	выполняется посимвольная обработка вводимых данных
	и одновременное преобразование в обеих
	шкалах</i>
	</caption>
  </center>
  </div>
<p> В разветвленном интерфейсе нет необходимости в
  разделителе. Кроме того, пользователю не нужно
  указывать, какое именно преобразование требуется
  провести. GOMS-анализ показывает, что для 4
  символов, которые в среднем будут вводиться,
  запись будет следующей:</p>
<p> <var>M K K K K</var></p>
<p> В разветвленном интерфейсе достигается минимальное
  время 2.15&nbsp;с, и его символьная эффективность
  составляет 100%.</p>
<p> Если, как в нашем примере, в месте вывода
  происходит изменение результата в тот момент,
  когда символы вводятся, это колебание цифр не
  отвлекает пользователя, потому что в локусе его
  внимания находится именно ввод данных. Непрерывно
  изменяемые значения на выводе могут быть даже
  полезными&nbsp;&mdash; после нескольких применений
  пользователь будет замечать эти колебания только
  краем глаза, что будет служить подсказкой о том,
  что система отвечает на вводимые данные. Если
  используется посимвольный режим работы интерфейса,
  то для большей эффективности такая система должна
  реагировать довольно быстро. В частности скорость
  реакции не должна быть меньше скорости ввода.
  Такая проблема может возникать только при сетевом
  использовании интерфейса.</p>
  
<p> <a name="p119"></a> Хотя это и не входит в условие задачи, но может
  возникнуть вопрос о том, как происходит очистка
  полей в преобразователе для выполнения следующего
  преобразования. Добавляет ли операция очистки еще
  одно нажатие клавиши? Необязательно. Например, мы
  можем разработать интерфейс таким образом, что
  каждый раз, когда оператор возвращается к своему
  основному занятию или переходит к другой задаче,
  значения, указанные в преобразователе, могут
  автоматически затеняться, а сам температурный
  преобразователь становиться неактивным; причем в
  это время все значения могут оставаться в своих
  полях так, что при необходимости их можно было бы
  опять увидеть, но уже при следующем вводе все они
  будут стерты.</p>
  
<p> Разветвленный интерфейс не обязательно является
  самым лучшим из тех, что уже были рассмотрены&nbsp;&mdash;
  или из тех, что возможны,&nbsp;&mdash; только потому, что
  он имеет оптимальную скорость работы и является
  весьма эффективным. Кроме скорости есть и другие
  параметры, которые также являются важными: частота
  появления ошибок; время, необходимое для изучения
  интерфейса; возможность длительного запоминания
  способа использования интерфейса. Особенно следует
  обратить внимание на частоту появления ошибок в
  разветвленном интерфейсе, поскольку есть
  вероятность того, что Хол может прочитать
  результат не из того поля. Это важно особенно
  потому, что когда он услышал, например слово <i>Цельсий</i>, ему необходимо прочитать значение
  из поля шкалы Фаренгейта. Тем не менее,
  разветвленный температурный преобразователь
  определенно входит в небольшое число тех
  интерфейсов, которые можно рассматривать как
  рабочие варианты для программы преобразования
  температурных значений из одной шкалы в другую.
  Другие рассмотренные нами примеры, которые могли
  бы показаться удачными, если бы мы не проводили с
  ними GOMS-анализ, на самом деле не являются
  таковыми.</p>
  
<p> Используемая как в простом анализе временных
  затрат на нажатия клавиш, так и в полном
  информационно-теоретическом исследовании,
  квантификация теоретического интерфейса с
  минимальным временем использования или с
  минимальным количеством используемых символов, или
  с минимальным количеством используемой информации
  может быть полезна с точки зрения разработки
  интерфейса. <i>Без количественных ориентиров мы
  можем только догадываться о том, насколько хорошо
  мы разработали интерфейс и есть ли возможность его
  улучшения.</i></p>
  
<h2>4.4. Закон Фитса и закон Хика</h2>

<div class="slogan">
<blockquote><p>Основы знаний надлежит искать в
  математике.</p><cite>
  Роджер Бэкон &laquo;Opus Majus&raquo;, XIII
  в.</cite></blockquote></div>
  
<p> Различные количественные законы, имеющие отношение
  к разработке интерфейсов, имеют хорошее
  когнитивное обоснование, и их правильность была
  неоднократно проверена. Эти законы часто дают нам
  дополнительные<a name="p120"></a> данные, на основе которых можно
  принимать те или иные решения, связанные с
  разработкой интерфейсов. Закон Фитса (Fitts' Law)
  позволяет определить количественно тот факт, что
  чем дальше находится объект от текущей позиции
  курсора или чем меньше размеры этого объекта, тем
  больше времени потребуется пользователю для
  перемещения к нему курсора. Закон Хика (Hick's
  Law) позволяет количественно определить
  наблюдение, заключающееся в том, что чем больше
  количество вариантов заданного типа вы
  предоставляете, тем больше времени требуется на
  выбор.</p>
  
<h3>4.4.1. Закон Фитса</h3>
<p> Представим, что вы перемещаете курсор к кнопке,
  изображенной на экране. Кнопка является <i>целью</i> данного перемещения. Длина прямой
  линии, соединяющей начальную позицию курсора и
  ближайшую точку целевого объекта, определяется в
  законе Фитса как <i>дистанция</i>. На основе
  данных о размерах объекта и дистанции <b>закон
  Фитса</b> позволяет найти среднее время, за
  которое пользователь сможет переместить курсор к
  кнопке.</p>
  
<p> В одномерном случае, при котором размер объекта
  вдоль линии перемещения курсора обозначается как <var>S</var>, а дистанция от начальной позиции курсора
  до объекта&nbsp;&mdash; как <var>D</var> (рис.&nbsp;4.6), закон Фитса
  формулируется следующим образом:</p>
  
<p> <var>Время (мс) = a + b \log_2(D/S+1)</var></p>
<p> (Константы <var>a</var> и <var>b</var> устанавливаются
  опытным путем по параметрам производительности
  человека.)<a name="r26" href="#f26"><sup>26</sup></a></p>

  <div class="image">
  <center>
	<img
src="img_4-6.jpg"/><br>
	<caption>
	<i><b>Рис.&nbsp;4.6.</b> Расстояния, которые используются в законе Фитса
	для определения времени, необходимого для
	перемещения курсора к цели</i>
	</caption>
  </center>
  </div>
  
<p> Вычисляемое время отсчитывается от момента, когда
  курсор начинает движение по прямой линии, до
  момента, когда пользователь щелкает мышью по
  целевому объекту. Логарифм по основанию 2 является
  мерой трудности задачи в количестве бит
  информации, которое требуется для описания
  (одномерного) пути перемещения курсора.</p>
  
<p> <a name="p121"></a> Для вычисления времени можно использовать любые
  единицы измерения дистанции, т.к. <var>D/S</var> является отношением двух дистанций и поэтому не
  зависит от единицы измерения. Отсюда следует, что
  хотя указательное устройство может переместиться
  на расстояние большее или меньшее, чем то
  расстояние, на которое переместится на экране
  курсор, закон все равно работает, при условии, что
  соотношение между движением ГУВ и курсора является
  линейным. Закон Фитса может применяться только к
  тем типам перемещения, которые совершаются при
  использовании большинства человеко-машинных
  интерфейсов, т.е. к таким перемещениям, которые
  невелики относительно размеров человеческого тела
  и которые являются непрерывными (совершаемыми
  одним движением). Для приближенных вычислений я
  использую следующие значения констант в уравнении
  закона Фитса: <var>a=50</var>, <var>b=150</var>.
<p> Также проводились тестирования с законом Фитса,
  дополненным некоторыми более сложными параметрами,
  такими, например, как перемещение курсора между
  прямыми или искривленными границами (Accot и Zhai,
  1997). Для двумерных целей обычно можно получить
  корректное приближенное значение времени,
  необходимого для перемещения курсора к объекту,
  используя в качестве параметра <var>S</var> наименьшее
  из значений размеров объекта по горизонтали или по
  вертикали (Mackenzie, 1995).</p>

  <div class="image">
  <center>
	<img
src="img_4-7.jpg"/><br>
	<caption>
	<i><b>Рис.&nbsp;4.7.</b> Меню в Macintosh, расположенное у верхней границы
	экрана, увеличивается в размере, что является
	более эффективным по сравнению с меню, которое
	всплывает из-за границы
	экрана</i>
	</caption>
  </center>
  </div>
  
<p> Закон Фитса позволяет объяснить, например, почему
  переместить курсор к меню в стиле Apple Macintosh,
  располагающемуся на границе экрана (рис.&nbsp;4.7),
  намного быстрее, чем переместить курсор к меню в
  стиле Microsoft Windows, которое всплывает из-за
  границы экрана (рис.&nbsp;4.8). Размер <var>S</var> меню в
  Windows на моем экране составляет 5&nbsp;мм.
  Эффективный размер меню в Macintosh является
  довольно большим,
  потому<a name="p122"></a> что пользователю не требуется
  останавливаться в пределах полосы меню; он может
  просто передвинуть ГУВ на любое расстояние
  превышающее расстояние, необходимое для размещения
  курсора в пределах меню,&nbsp;&mdash; курсор в любом
  случае остановится на границе экрана.</p>

  <div class="image">
  <center>
	<img
src="img_4-8.jpg"><br>
	<caption>
	<i><b>Рис.&nbsp;4.8.</b> Меню в Windows находится под верхней границей
	экрана, поэтому пользователю нужно более точно
	подводить курсор к меню, чтобы, можно было вызвать
	подменю</i>
	</caption>
  </center>
  </div>
  
<p> Ряд выполненных мной тестов помог установить, что
  пользователи Macintosh обычно останавливаются в
  пределах 50 мм от границы экрана, поэтому для
  Macintosh мы можем принять 50 мм как <var>S</var>. При
  использовании 14-дюймового плоского монитора
  среднее расстояние, на которое требуется
  переместить курсор, чтобы достичь панели меню,
  составляет 80 мм. Таким образом, время перемещения
  курсора к какому-либо из элементов меню в
  Macintosh будет:</p>
<p> <var>50 + 150 \log_2(80/50+1) = 256 мс</var></p>
<p> Это время является намного меньшим, чем то,
  которое требуется на перемещение курсора к
  необходимому элементу меню в Windows:</p>
<p> <var>50 + 150 \log_2(80/5+1) = 663 мс</var></p>
<p> Полученные значения времени относятся только лишь
  к перемещению курсора. Щелчок по целевому объекту,
  к которому перемещался курсор, добавляет в среднем
  еще 0.1&nbsp;с. (Значение оператора <var>K=0.2</var>,
  принятое в модели GOMS, учитывает и нажатие
  кнопки, и ее отпускание, в то время как указанное
  значение учитывает только нажатие кнопки.) При
  проведении обычного эксперимента вам придется
  добавить еще 0.25&nbsp;с, чтобы учесть время
  человеческой реакции в начале движения курсора. С
  учетом всех этих факторов мы получим именно те
  значения, которые я получил экспериментальным
  путем: в среднем пользователю требуется около 0.6&nbsp;с, чтобы открыть Apple-меню, в то время как для
  открытия Windows-меню требуется более 1&nbsp;с. Таким
  образом, этот анализ объясняет, почему при
  разработке интерфейса Macintosh меню были
  намеренно помещены на границе экрана.</p>
  
<h3>4.4.2. Закон Хика</h3>

<p> Перед тем как переместить курсор к цели или
  совершить любое другое действие из набора
  множества вариантов, пользователь должен выбрать
  этот объект или действие. В законе Хика
  утверждается, что когда необходимо сделать выбор
  из <var>n</var> вариантов, время на выбор одного из
  них будет пропорционально логарифму по основанию 2
  от числа вариантов плюс 1, при условии, что все
  варианты являются равновероятными. В этом виде
  закон Хика очень похож на закон Фитса:</p>
<p> <var>Время (мс) = a + b \log_2(n+1)</var></p>
<p> Если вероятность 1-го варианта равна <var>p(i)</var>,
  то вместо логарифмического коэффициента
  используется</p>
<p> <var>\sum_i p(i) \log_2(1/p(i)+1)</var></p>
<p> Коэффициенты, используемые в выражении закона
  Хика, в большой степени зависят от многих условий,
  включая то, как представлены возможные варианты, и
  то, насколько хорошо пользователь знаком с
  системой. (Если варианты представлены непонятным
  образом, значения <var>a</var> и <var>b</var> возрастают.
  Наличие навыков и привычек в использовании системы
  снижает значение <var>b</var>.) Мы не будем
  рассматривать эти зависимости&nbsp;&mdash; для нас важно,
  что для принятия того или иного решения требуется
  время; что для принятия сложных решений требуется
  больше времени, чем для принятия простых решений;
  и что взаимосвязь является логарифмической. При
  отсутствии более точных данных для проведения
  быстрых и приблизительных вычислений мы можем
  воспользоваться теми же значениями <var>a</var> и <var>b</var>, которые использовали для закона Фитса.</p>
  
<p> При использовании любых положительных и ненулевых
  значений <var>a</var> и <var>b</var> из закона Хика следует, что
  предоставление пользователю сразу нескольких
  вариантов одновременно обычно является более
  эффективным, чем организация тех же вариантов в
  иерархические группы. Выбор из одного меню,
  состоящего из 8 элементов, производится быстрее,
  чем из двух меню, состоящих их 4 элементов каждое.
  Если все элементы могут быть выбраны с равной
  вероятностью и если не учитывать время,
  необходимое для открытия второго меню (которое,
  конечно, еще более увеличило бы время для
  интерфейса, состоящего из двух меню), то сравнение
  времени для выбора одного элемента из восьми
  (<var>a + b \log_2 8</var>) с удвоенным
  временем для выбора одного элемента из четырех 2
  (<var>a + b \log_2 4</var>) покажет, что</p>
<p> <var>а + 3b &lt; 2(а + 2b)</var></p>
<p> поскольку <var>\log_2 8 = 3</var>, a <var>\log_2 4 = 2</var>, а также
  поскольку <var>a&lt;2a</var> и <var>3b&lt;4b</var>.</p>
<p> Это согласуется с данными, полученными в
  экспериментах со структурами меню (см. например,
  Norman и Chin, 1988).</p>
<p> <a name="p124"></a> Наше рассмотрение законов Фитса и Хика нельзя
  считать полным. Например, следует обратить
  внимание на то, что эти законы не случайно
  принимают ту же форму, что и теорема
  Шэннона&nbsp;&mdash; Хартли (Shannon-Hartley). Тем не менее,
  этого короткого рассмотрения вполне достаточно для
  того, чтобы отметить их ценность с точки зрения
  разработки интерфейсов. Они могут быть полезными
  даже в том случае, когда эмпирические значения
  коэффициентов <var>a</var> и <var>b</var> не известны (как
  это было в нашем примере). (Более подробные
  сведения см. в Card, Moran и Newell, 1983,
  с.&nbsp;72-74.)</p>
<hr>
<p><a name="f20" href="#r20"><sup>20</sup></a> Дискликсия (dysclicksia)&nbsp;&mdash; от англ. слова click
  (щелкнуть мышью) и приставки dis- (нарушение
  функции).&nbsp;&mdash; <i>Примеч. пер.</i></p>
<p><a name="f21" href="#r21"><sup>21</sup></a> Термин <i>дискликсия</i> (dysclicksia),
  означающий заболевание, единственным лекарством от
  которого является хорошо разработанный интерфейс,
  был предложен Памом Мартином (Pam Martin)
  (переписка, 1997).</p>
<p><a name="f22" href="#r22"><sup>22</sup></a> Можно разработать и более сложные критерии
  производительности. Например, как в нашем случае,
  оператор <var>M</var> не используется в вычислениях.
  Тем не менее, простой критерий, который здесь
  описан, вполне достаточен для нашего рассмотрения.</p>
<p><a name="f23" href="#r23"><sup>23</sup></a> Слово бит (bit) было предложено математиком
  Джоном У. Тюки (John W. Tukey) как сокращение от
  слов &laquo;двоичная цифра&raquo; (Binary digiT) (Shannon и
  Weaver, 1963, стр. 9).</p>
<p><a name="f24" href="#r24"><sup>24</sup></a> Слово &laquo;почти&raquo; здесь используется потому, что
  температура 0 градусов не будет вводиться как 0.00
  или 00.0.</p>
<p><a name="f25" href="#r25"><sup>25</sup></a> Для извлечения логарифма по основанию 2 с помощью
  калькулятора или компьютера, в котором возможно
  вычислять только натуральные логарифмы,
  используйте следующее выражение: <var>\log_2(х)
  = \ln(х)/\ln(2)</var>.</p>
<p><a name="f26" href="#r26"><sup>26</sup></a> В математике, которая считается образцом точности
  и ясности, все еще применяется старый стиль
  написания формул, в котором неопределенные
  переменные пишутся в начале, еще до того, как вы
  можете узнать, что они обозначают. Например, можно
  встретить выражение наподобие следующего:</p>
<p> <var>A = \pi r^2</var>,</p>
<p> где <var>r</var> является радиусом окружности, а <var>A</var>&nbsp;&mdash; ее площадью.</p>
<p> Такой порядок может
  приводить к путанице, поскольку читателю
  приходится перечитывать выражение еще раз сначала,
  особенно если оно довольно длинное и содержит
  множество других неопределенных переменных. С
  точки зрения читателя намного удобнее следовать
  естественному порядку, в котором термины
  определяются <i>до</i> их использования:</p>
<p> Окружность с радиусом <var>r</var> имеет площадь <var>A</var>,
  вычисляемую как:</p>
<p> <var>A = \pi r^2</var></p>

		<div class="page">
		<p class="back"><a href="chapter3.html">&lt;=&nbsp;Previous</a></p>
		<p class="next"><a href="chapter5.html">Next&nbsp;=&gt;</a></p>
		</div>